<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <title>Sleep Language Reference</title>
  <meta name="Copyright" content="This file may be redistributed and/or modified without limitation" />
  <meta name="Language" content="en" />
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <meta http-equiv="Content-Language" content="en" />
  <link rel="StyleSheet" href="css/screen.css" type="text/css" media="screen" />
  <link rel="StyleSheet" href="css/print.css" type="text/css" media="print" />
</head>

<body>
<h1>Sleep Language Fundamentals</h1>

<p>This document covers the fundamentals of the sleep language in an application neutral way.   The format of this documentation 
is a mix between a tutorial and a reference.  You should be able to read straight through this documentation to gain an initial 
understanding of sleep and later use it as a reference.</p>

<h3>Sections</h3>
<ol>
<li><a href="#1">Scalar Variables</a></li>
<li><a href="#2">If-Else Statements</a></li>
<li><a href="#3">Loops</a></li>
<li><a href="#4">Number Crunching</a></li>
<li><a href="#5">Subroutines</a></li>
<li><a href="#6">Arrays</a></li>
<li><a href="#7">Hashes</a></li>
<li><a href="#8">String Manipulation</a></li>
<li><a href="#9">Input/Output Capabilities</a></li>
<li><a href="#10">Working with Objects</a></li>
<li><a href="#10a">Sleep Closures</a></li>
<li><a href="#11">Function Library</a></li>
<li><a href="#12">A - System Properties</a></li>
<li><a href="#13">B - Wildcard Strings</a></li>
<li><a href="#14">C - Regular Expression Syntax</a></li>
<li><a href="#15">D - Date/Time Formats</a></li>
<li><a href="#16">E - Binary Data Format Strings</a></li>
<li><a href="#17">F - Transliteration Syntax</a></li>
</ol>

<h2><a name="1">Scalar Variables</a></h2>

<p>Variables in sleep are temporary locations in memory to store a value.  Variables in sleep are called scalars.  Scalars can be 
strings, numbers, or even a reference to an object.</p>

<p>Scalar variable names always begin with the $ dollar sign.</p>

<h3>Assignment</h3>

<p>Values are assigned to scalars using the = sign.  For example</p>

<pre>$x = 3;
$y = $x;</pre>

<p>The above puts the integer 3 into the scalar <var>$x</var>.  <var>$x</var> now contains the integer 3 until something else is 
assigned to it.  Likewise the value of <var>$x</var> is copied into <var>$y</var>.  <var>$y</var> now contains the value 3.</p>

<h3>Operations</h3>

<p>You can also assign the result of an operation to a scalar.  An operation consists of two values and an operator.   The 
following are examples of valid operations.</p>

<pre>$x = 5 + 1;
$x = 5 - $y;
$x = $x * 2;
$x = $z / $2;
$x = $1 % 3;  # modulus
$x = $1 ** 4; # exponentation operator</pre>

<p>Those operations only work on numbers though.  Sleep operations for strings include:</p>

<pre>$x = "Ice" . "cream";</pre>

<p>The above is an example of the concatenation operator.  The . period combines two strings together.  <var>$x</var> now has the 
string value "Icecream".</p>

<pre>$x = "abc" x 3;</pre>

<p>The above is an example of the string multiplication operator.  The resulting string is the left hand side repeated by the 
number on the right hand side.  In the above example the value of <var>$x</var> would be "abcabcabc".  Basically "abc" repeated 3 
times.</p>

<p>Sleep also includes a set of logical operators.  These include <var>&lt;&lt;</var>, <var>&gt;&gt;</var>, <var>^</var>, 
<var>|</var>, <var>&amp;</var>, and a 
function <var>&amp;not()</var>.</p>

<h3>Expressions</h3>

<p>Multiple operations can be combined to form an expression. For example</p>

<pre>$z = 5 + 1 * 3;</pre>

<p>Is valid.  The +, -, and . operators have a lower precedence than *, /, and %.  So the above would be equivalent to:</p>

<pre>$z = 5 + (1 * 3);</pre>

<p>You can use ( ) parentheses to enclose an operation that you want to have evaluated first.  Complex expressions are allowed as 
well:</p>

<pre>$z = 3 * ($x % 3) - (ticks() / (10000 + 1));</pre>

<h3>Use of White Space</h3>

<p>Sleep scripts require you to use white space in expressions.  Most languages allow you to get away with very little white space.  For 
example in Perl the following would be valid.</p>

<pre>$x=1+2;</pre>

<p>The above is not valid in sleep.  You are always expected to use white space between operators and the stuff they are 
operating on.  For example:</p>

<pre>$x = 1 + 2;</pre>

<p>Is valid.  Think of it as a feature that forces some reasonable coding habits.</p>

<h3>Scalar Types</h3>

<p>Scalars can hold several types of data.  The most common ones you will deal with are numbers and strings.</p>

<p>Any scalar value can be treated as a string... period.  The scalar value 3 is equivalent to the string "3".   Strings are 
covered more in their own section: String Manipulation.</p>

<p>Sleep supports three types of scalars for numbers.  Rational numbers such as 3, 4, 5 ... 65536 are all integer values.  
Numbers that have a decimal in them such as 3.0, 1.1, 0.55556 are all double values.   A double value is assigned to a scalar 
as follows:</p>

<pre>$Pi = 3.1415926535;</pre>

<p>Rational numbers can be specified as hex literals.  Any number beginning with a 0x is turned into an integer scalar. 
i.e.</p>

<pre>$var = 0xFF; # same as $var = 255</pre>

<p>Octal literals can be used as well.  Any number beginning with a 0 is interpreted to be an octal literal. i.e.</p>

<pre>$oct = 077; # same as $oct = 63</pre>

<p>Another numerical type that sleep supports is called a long.  A long is basically a higher capacity integer.  An integer can 
be a number between -2,147,483,648 to +2,147,483,648.  A long can be much bigger than that.</p>

<p>Longs can be explicitly declared by adding an L to the end of the number i.e.: <code>12345L</code> would be a long 
scalar.  Adding an L to the end of the number works for coercing hex and octal literals to longs as well.</p>

<p>Numerical scalars are covered more in their own section: Number Crunching.</p>

<h3>Other Scalar Types</h3>

<p>Two other scalar types you may encounter are the null scalar and object scalars.</p>

<p>The null scalar is a scalar that is equivalent to nothing.   It is a string with no characters, the number 0, and does not 
reference anything.  The null scalar has a built-in name <var>$null</var>.  <var>$null</var> always refers to the null 
scalar.</p>

<p>Object scalars are created by various functions.  For example if you use the open() function to open a file, the open function 
will return an object scalar that contains a reference to the internal information needed by the I/O system.   Object values have 
a numerical value that is equivalent to their hash code (a number java calculates for each object).   Object values have a string 
value as well.</p>

<h3>How Scalars are Passed</h3>

<p>It is important to understand the concept of pass by reference and pass by value.  Sleep string scalars and number scalars are 
always passed by value.  Pass by value means that when a scalar <var>$x</var> is assigned to scalar <var>$y</var>, a copy of the 
value of <var>$x</var> is made and then assigned to <var>$y</var>.</p>

<pre>$x = 3;
$y = $x;
$x = 4;</pre>

<p>In the above scenario <var>$x</var> is initially 3.  Then <var>$y</var> is assigned a copy of <var>$x</var> which is 3.  
<var>$y</var> now has the value 3.  In the last line <var>$x</var> is assigned the value 4.  This does not affect <var>$y</var>, 
since <var>$y</var> only has a copy of the contents of <var>$x</var>.  Not the actual value.</p>

<p>Data structures (arrays, hashes) and object scalars are passed by reference.  All data has a place in memory somewhere.  A 
reference is a variable containing the address of some type of data in memory.  If two scalars have the same reference, then any 
changes to the data either scalar is referring two will affect both scalars. This happens because the two scalars reference the 
same data.  An example:</p>

<pre>@foo[0] = "Ice Cream";
@bar = @foo;
@bar[0] = "Gelato";

# what is the value of @foo[0]?</pre>

<p>Getting a little ahead of ourselves but any variable with an @ is an array.  The first line of the above example assigns "Ice 
Cream" to position 0 in the array <var>@foo</var>.   The second line assigns the array <var>@foo</var> to <var>@bar</var>.  
Arrays are big objects so it is not efficient to copy the array.  Rather the reference to the array data is copied.  
<var>@bar</var> now references the same array data as <var>@foo</var>.  The string "Gelato" is assigned to position 0 in the 
array <var>@foo</var>.   Since <var>@foo</var> and <var>@bar</var> are the same array in memory the value of <var>@foo[0]</var> 
is "Gelato".</p>

<p>As a side note: assignment of individual array elements with string or number values works just like assigning individual 
scalars.  In fact individual array elements are for all intents and purposes normal scalars.</p>

<h3>Scalar Scope</h3>

<p>Sleep has two types of scope.  A global scope and a local scope.  Scope is an attribute of variables that defines where they 
exist and can be referenced from.  A variable that has global scope can be accessed any where in the script.  Once created the 
scalar does not go away unless explicitly told to do so.</p>

<p>Sleep scalars have a global scope by default.</p>

<p>A variable that has local scope is considered to be local to a specific function.   The variable is alive while the function 
is being executed.  Once the function exits the variable goes away.   Local variables have higher precedence than global 
variables.  Local variables do not affect global variables.</P>

<pre>sub verdict
{
   local('$decision');
   $decision = "not guilty";
}

$decision = "guilty";
verdict();

# what is the value of $decision?</pre>

<p>In the above example the subroutine verdict is declared. Sleep has several types of functions, a subroutine is just one type 
of function.  <var>$decision</var> is then assigned the value "guilty".  The subroutine example is then called.  Inside of 
verdict <var>$decision</var> is declared as a local variable for verdict.  <var>$decision</var> is then assigned the value "not 
guilty".   The subroutine verdict is now done.  At the end of the day what is the value of <var>$decision</var>?  The answer is
"guilty".</P>

<p>When <var>$decision</var> was declared as a local variable within verdict, a new local variable <var>$decision</var> was 
created with no value.  This local variable has nothing to do with the global variable <var>$decision</var>.  The local variable 
<var>$decision</var> was then assigned the value "not guilty".  When the subroutine verdict finished executing the local variable
<var>$decision</var> went away.  The global variable <var>$decision</var> was not touched.</p>

<h3>Scalar Identity</h3>

<p>In general Sleep tries to hide the type of the data you're working with.  You can use strings, numbers, and objects interchangeably 
in many cases.</p>

<p>Sleep has built-in array and hash (dictionary) data structures for storing scalars.  The concept of scalar identity was invented to
help with manipulating and querying these data structures.  For example the <code>&amp;addAll</code> function is a way to union two
arrays together.  Scalars are judged as being equivalent through scalar identity.</p>

<p>If a scalar holds a reference to a value (i.e. a hash, an object, or an array) then the identity of that scalar is the reference 
itself.  Otherwise the identity is based on the string form of the value.</p>

<p>The <code>=~</code> operator exists for checking if two scalars share the same identity.  Really though you only need to know about
this concept to understand how the <code>in</code> predicate works and how <code>&amp;addAll</code>, <code>&amp;retainAll</code>, and
<code>&amp;removeAll</code> work.</p>

<h2><a name="2">If-Else Statements</a></h2>

<p>If-Else statements let you compare different values and execute a certain part of the script based on the result of the 
comparison.</p>

<p>The basic format of an if-else statement is:</p>

<pre>if (<b>v1 operator v2</b>) { <b>commands</b> }
else if (<b>v3 operator v4</b>) { <b>commands</b> }
else { <b>commands</b> }</pre>

<p>The ( ) parentheses enclose the comparisons while the { } brackets enclose the commands to execute.  If the comparison within 
the ( ) parentheses is true then the following commands are executed.  If the initial comparison is false then the else statement 
is executed.  Else statements can be followed by either a block of statements enclosed in { } brackets or by another if 
statement.</p>

<h3>The Operators</h3>

<h4>Numerical Comparisons</h4>

<table class="simple2">
 <tr>
  <th>Operator</th>
  <th>Description</th>
 </tr>
 <tr>
  <td>==</td>
  <td>equal to</td>
 </tr>
 <tr>
  <td>!=</td>
  <td>not equal to</td>
 </tr>
 <tr>
  <td>&lt;</td>
  <td>less than</td>
 </tr>
 <tr>
  <td>&gt;</td>
  <td>greater than</td>
 </tr>
 <tr>
  <td>&lt;=</td>
  <td>less than or equal to</td>
 </tr>
 <tr>
  <td>&gt;=</td>
  <td>greater than or equal to</td>
 </tr>
</table>

<h4>String Comparisons</h4>

<table class="simple2">
 <tr>
  <th>Operator</th>
  <th>Description</th>
 </tr>
 <tr>
  <td>eq</td>
  <td>equal to</td>
 </tr>
 <tr>
  <td>ne</td>
  <td>not equal to</td>
 </tr>
 <tr>
  <td>lt</td>
  <td>string v1 is less than string v2</td>
 </tr>
 <tr>
  <td>gt</td>
  <td>string v1 is greater than string v2</td>
 </tr>
 <tr>
  <td>isin</td>
  <td>substring v1 is contained in string v2</td>
 </tr>
 <tr>
  <td>iswm</td>
  <td>wildcard string v1 matches string v2 (see <a href="#13">Appendix B</a>)</td>
 </tr>
</table>

<h4>Other Comparisons</h4>

<table class="simple2">
 <tr>
  <th>Operator</th>
  <th>Description</th>
 </tr>
 <tr>
  <td>in</td>
  <td>true if scalar v1 identity exists in array/generator v2</td>
 </tr>
 <tr>
  <td>is</td>
  <td>true if scalar object reference v1 equals object reference v2</td>
 </tr>
 <tr>  
  <td>isa</td>
  <td>true if scalar object reference v1 is an instance of the Class referenced by scalar v2</td>
 </tr>
 <tr>  
  <td>=~</td>
  <td>true if scalar v1 identity is equal to scalar v2 identity</td>
 </tr>
</table>

<p>One example use of the <code>is</code> comparison is to check if a function really returned
<var>$null</var> and not just an empty string:</p>

<pre>if ($null is "")
{
   println("This will not print");
}

if ($null is 0)
{
   println("This will not print either.");
}

if ($null is $null)
{
   println("Bingo!");
}</pre>

<p>Most comparisons in sleep can be negated with the ! exclamation point before the operator in the comparison.</p>

<pre>if ("test" !isin "walrus")
{
   # the string "test" is not contained in the string "walrus"
}</pre>

<p>The <code>isa</code> predicate is covered later in the <i>Class Literals</i> subsection of this document.</p>

<h3>Combining Comparisons</h3>

<p>Comparisons can be combined using the logical operators && for AND and || for OR.  For example:</p>

<pre>sub check
{
   if (($1 > 0) && ($1 <= 10))
   {
      # $1 is greater than 0 and $1 is less than or equal to 10.
   }
}</pre>

<p>The above subroutine checks if the parameter <var>$1</var> is between 1 and 10.  The first comparison makes sure <var>$1</var> 
is greater than 0.  If <var>$1</var> is less than 0 then the comparison stops immediately.  For the condition in the if  
statement to be true <var>$1</var> has to be greater than 0 AND <var>$1</var> has to be less than or equal to 10.</p>

<h3>Unary Operators</h3>

<p>Many of the comparison operators have a left and a right parameter.  Sleep also has unary comparison operators.  Meaning the 
comparison operator has only one parameter.   Unary operators are recognizable as they always begin with the - dash 
character.</p>

<p>Unary operators can be negated by putting an ! exclamation point before the - in the operator.</p>

<table class="simple2">
 <tr>
  <th>Operator</th>
  <th>Description</th>
 </tr>
 <tr>
  <td>-isarray</td>
  <td>is the specified value a scalar array</td>
 </tr>
 <tr>
  <td>-isfunction</td>
  <td>does the specified scalar hold a function</td>
 </tr>
 <tr>
  <td>-ishash</td>
  <td>is the specified value a scalar hash</td>
 </tr>
 <tr>
  <td>-isletter</td>
  <td>is the specified character a letter</td>
 </tr>
 <tr>
  <td>-isnumber</td>
  <td>is the specified string a number</td>
 </tr>
 <tr>
  <td>-istrue</td>
  <td>is the specified value non-null</td>
 </tr>
</table>

<pre>if (-isnumber "3")
{
   # true because 3 is a number
}</pre>

<p>The above checks if 3 is a number.  Unary operators can be combined with normal comparison operators using && AND and || 
OR.</p>

<p>It is also possible to use a scalar by itself as the comparison for an if statement.  A scalar that has any value other than 
the null scalar will result in the comparison being true.</p>

<pre>if ($scalar)
{
   # execute me
}</pre>

<p>The above is the same as doing a comparison using the -istrue operator with <var>$scalar</var> as the parameter.</p>

<h3>The Conditional Operator</h3>

<p>Sleep has a conditional operator iff.  iff takes a condition as it's first parameter and returns it's second parameter if and 
only if the condition is true.  The third parameter is returned if and only if the condition is false.</p>

<pre>iff(comparison, expression_if_true, expression_if_false)</pre>

<p>An example:</p>

<pre>$value = "Calculation took" . $x . " second" . iff($x > 1, "s", "");</pre>

<p><var>$value</var> would be "Calculation took 2 seconds" if $x is equal to 2.  If <var>$x</var> was equal to 0 then 
<var>$value</var> would be "Calculation took 1 second".  The iff example above checks if <var>$x</var> is greater than 1.  If it 
is then "s" is returned.  Otherwise "" is returned.</p>

<h3>Assertions</h3>

<p>Now that you know about predicates and conditions, I can introduce assertions.  Assertions are a really basic debugging mechanism.  An assertion is a quick way to check that a condition is true.  If the condition isn't true, the current script will exit with an error message.  The syntax for an assertion is:</p>

<pre>assert <b>comparison</b>;</pre>

<p>Assertions also allow a message to be attached.  The attached message is echoed whenever an assertion fails.</p>

<pre>assert <b>comparison</b> : <b>message</b>;</pre>

<p>Assertions are great for doing a last minute sanity check of some condition.  Can you tell what is wrong with this code snippet?</P>

<pre>sub fact
{
   return iff($1 == 0, 1, $1 * fact($1 - 1));
}</pre>

<p>If someone were to call fact with a negative argument, the script would go into an infinite loop potentially crashing Sleep and/or the app hosting it.  An assertion can provide a quick sanity check to protect against this.</p>

<pre>sub fact
{
   assert $1 >= 0 : "invalid arg for fact: $1";
   return iff($1 == 0, 1, $1 * fact($1 - 1));
}</pre>

<h2><a name="3">Loops</a></h2>

<h3>While Loops</h3>

<p>While loops are a way of executing certain statements while a comparison continues to be true.</p>

<pre>while (<b>comparison</b>) { <b>commands</b> }</pre>

<p>An example of a while loop that counts to 100:</p>

<pre>$x = 0;
while ($x < 100)
{
   $x = $x + 1;
}</pre>

<h3>For Loops</h3>

<p>For loops are the same as while loops except they have a few syntax differences.  The following for loop is equivalent to the 
code in the above example.</p>

<pre>for ($x = 0; $x < 100; $x = $x + 1) { }</pre>

<h3>Assignment Loops</h3>

<p>While loops can be used in another way.  Namely to assign the results of an expression to a scalar and then execute
a series of commands while the specified expression does not evaluate to $null.</p>

<p>The syntax for these assignment loops looks like:</p>

<pre>while <b>$variable</b> (<b>expression</b>) { <b>commands</b> }</pre>

<p>This form of a while loop has numerous uses including easily reading from a file.  For example:</p>

<pre>$handle = openf("myfile.txt");
while $text (readln($handle))
{
   println("Read a line of text from myfile.txt: $text");
}</pre>

<p>In the example above, myfile.txt is opened and the handle is assigned to $handle.  readln is then continuously called
on $handle and the result assigned to $text.  Each time this happens the print function in the body of the loop is called.
When there is no more text to be read the function readln returns $null.  When this happens the loop finishes.</p>

<p>Assignment loops are used to iterate over any type of expression where as foreach loops are used to iterate over any
type of collection of date.  The assignment loop is the flexible cousin of the foreach loop.</p>

<h3>The Break Command</h3>

<p>Sometimes you may want to end a loop before it has completed.  An easy way to do this is with the break command.</p>

<p>An example:</p>

<pre>$x = 0;
while ($x < 100)
{
   if ($x == 50)
   {
      break;
   }

   $x = $x + 1;
}</pre>

<p>The loop example above is setup to count to 100.  Once the count reaches 50 though the loop is broken out of.  The break 
statement is a way of saying "this is the end of the loop, right here".</p>

<h3>The Continue Command</h3>

<p>Once in awhile it is useful to skip to the beginning of a loop ignoring the current element.  This is what the continue
command is for.</p>

<p>Another example:</p>

<pre>for ($x = 0; $x < 100; $x++)
{
   if ($x > 10 && $x < 90)
   {
      continue;
   }

   println($x);
}</pre>

<p>The loop above will print 0 .. 10, skip all values between 11 and 89, and then print 90 - 99.  The continue command
just jumps to the beginning of the loop again ignoring the current item.  Within a for loop the incremeter ($x++
in this example) is always executed even if continue is used.</p>

<h2><a name="4">Number Crunching</a></h2>

<p>The Scalars -> Expressions section introduced sleep's family of numerical scalars.</p>

<p>Strings used in numerical expressions are automatically converted to an integer scalar.</p>

<p>When performing an operation on scalar numbers of two different types a conversion occurs.  If either of the scalar numbers is 
a double, then the other scalar is converted to a double and the operation occurs.  If either of the scalar numbers is a long, 
then the other scalar is converted to a long and the operation occurs.  Integer scalars have the lowest priority.</p>

<p>It is possible to force a scalar to be a certain type of scalar number.  You can use the scalar casting functions.  These 
functions are:</p>

<table class="simple2">
 <tr>
  <th>Function</th>
  <th>Description</th>
 </tr>
 <tr>
  <td>double(<var>$x</var>)</td>
  <td>returns the value of <var>$x</var> as a double scalar</td>
 </tr>
 <tr>
  <td>long(<var>$x</var>)</td>
  <td>returns the value of <var>$x</var> as a long scalar</td>
 </tr>
 <tr>
  <td>int(<var>$x</var>)</td>
  <td>returns the value of <var>$x</var> as an int scalar</td>
 </tr>
</table>

<h3>Increment and Decrement Operators</h3>

<p>Sleep has a special operator for integer scalars.  Instead of typing</p>

<pre>$x = $x + 1;</pre>

<p>You can instead use the increment operator on the scalar <var>$x</var>.</p>

<pre>$x++;</pre>

<p>The two are equivalent.  <code>$x++</code> increments the value of <var>$x</var> and returns <code>$x + 1</code>.  The 
decrement operator does the same thing except for subtraction.  <code>$x--</code> decrements the value of <var>$x</var> and 
returns <code>$x - 1</code>.</p>
   
<p><code>$x--</code> is equivalent to <code>$x = $x - 1</code>;</p>

<h3>Assignment Operations</h3>

<p>Sleep has a special form of the assignment called an assignment operator.  This is essentially
the combination of an operator and an assignment in one step. i.e.:</p>

<code>$x += 3;</code>

<p>The example above is equivalent to <code>$x = $x + 3;</code>.  The following are valid assignment
operations: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, and <code>.=</code>.</p>

<h2><a name="5">Subroutines</a></h2>

<p>Subroutines in sleep are basically mini programs.  You can pass arguments to them and they can return values.</p>

<pre>sub add
{
   return $1 + $2;
}

$x = add(3, 4);</pre>

<p>The example above is an add subroutine.  <var>$x</var> will receive the result of the add subroutine.  Which is 7.  The 3 and 
4 separated by a comma are arguments to the subroutine.   Arguments are separated by commas Arguments to a subroutine in sleep are 
numbered beginning with <var>$1</var>.  So the first argument would be <var>$1</var>, the second argument <var>$2</var>, the 
third argument <var>$3</var> etc. All subroutines are placed in the global scope.</p>

<p>The special array <var>@_</var> contains all of the arguments for a subroutine as well.  <var>@_[0]</var> is <var>$1</var>, 
<var>@_[1]</var> is <var>$2</var>, etc.</p>

<h4>Pass by Reference</h4>

<p>Arguments passed to a Sleep subroutine are passed by "reference".  This means if you pass 
$fluffy as the first argument of a subroutine and that subroutine places a new value into $1 
then $fluffy will reflect that new value as well.  Example:</p>

<pre>sub test
{
  $1 = "bar";
}

$fluffy = "foo";
test($fluffy);</pre>

<p>The value of <var>$fluffy</var> after the code snippet above is executed is <b>bar</b>.</p>

<h3>The Return Command</h3>

<p>The return command causes the current subroutine to stop executing and return to where it started.  You can specify a scalar 
with return that will be the value of the function call.</p>

<h3><a name="throw"></a>Throwing Errors</h3>

<p>Sometimes an error or condition occurs that you don't want to handle in your subroutine but expect someone would
want to handle it higher up in the call stack.  This type of thing is referred to as an exceptional condition and 
Sleep has ample support for "exception" handling.</p>

<p>To notify Sleep that an exception has occured, use the throw command.  The throw command works similiarly to return
in that it expects you to specify a scalar that will be passed to an exception handler later on.  It is worth noteing
that if the thrown value evaluates to <var>$null</var> then it will not be thrown.</p>

<pre>sub multiplyBy3
{
   if (!-isnumber $1)
   {
      throw "&multipyBy3( $+ $1 $+ ) requires a number!";
   }

   return $1 * 3;
}</pre>

<p>The subroutine above checks if its argument is a number or not.  If someone where to call <code>multiplyBy3("hi")</code>
then this function would throw the string "&multiplyBy3(hi) requires a number!" up the call stack.   This string would
bubble up through the Sleep call stack.  The first part of the call stack to have a handler to catch the exception will 
get to handle it.  If there are no error handlers in place then a warning message will be printed: 
"Warning: Uncaught exception: &amp;multiplyBy3(hi) requires a number! at 5".  An uncaught exception will cause the 
current script to stop executing.</p>

<p>In general, an uncaught exception will be swallowed by Sleep.  There is one special case where this is not true and 
that is covered under <a href="#interfaces">Sleep Interfaces</a> later in this manual.</p>

<p>So with all of this in mind, hoes does one catch these exception errors?  The answer is to enclose executing code
into a try / catch block.</p>

<pre>try
{
   multiplyBy3("hi");
}
catch $message
{
   println("Failed to multiply by 3: $message");
   printAll(getStackTrace());
}</pre>

<p>The code above will attempt the multiplyBy3 within the try block.  The catch block immediately following the try
block will catch any error messages that bubble up while the try block is part of the call stack.  This means that if
<code>&amp;multiplyBy3</code> calls a function that calls another function that throws an exception - your catch block will still work
for catching that message.</p>

<p>In the example above <var>$message</var> is specified as the place to dump the exception message to.  When an 
exception handler is invoked, the variable specified after the catch keyword will be populated with the exception
message.</p>

<p>The function <code>&getStackTrace()</code> is a special function to describe where in your script the thrown message
originated from and which other functions were executed before leading to the thrown message.</p>

<h4><a name="choice"></a>Choice in Error Handling</h4>

<p>Sleep does not use this mechanism for flagging and reporting errors.  In general errors are made available with 
<code>&checkError($error)</code>.  This function will return the last reported error message flagged by Sleep or Java.
If you prefer to handle these types of errors with the try catch mechanism then you have two options:  

<p>You can throw individual errors yourself.  Simply inserting <code>throw checkError($error);</code> in certain places
will cause the error to be thrown if there is one.  If there is no error, <code>&amp;checkError($error)</code> will
return <var>$null</var>.  If this is the case then the throw command will not process it.  If there is an error then
the throw command will throw it and it will bubble up itself.</p>

<p>The other option is to enable the Sleep debug option to cause all errors to be thrown.  This option can be enabled
by calling: <code>debug(34)</code>.  With this debug option in place anything that would have been available to 
<code>&amp;checkError()</code> will be automatically converted into an exception and thrown.</p>

<p>The <code>&amp;checkError()</code> mechanism for handling errors is simple, requires little code on your part to
accomodate, and has support for automatic reporting through Sleep's debug flags.  The try/catch/throw mechanism requires
writing a little bit more code but the ability to retrieve the full stack trace that created the error condition can
be valuable for debugging.  Ultimately the choice is yours.  You can handle errors the Sleep <code>&amp;checkError()</code> 
way, the Java try/catch way, or somewhere in between.</p>

<h3>Arrays and Hashes as Arguments</h3>

<p>Arrays and Hashes can be passed to subroutines as arguments.</p>

<pre>sub clearArray
{
   clear($1);
}

clearArray(@data);</pre>

<p>In the above example we declare the subroutine clearArray.  All arguments to a subroutine are accessed as $1, $2, ... $n 
regardless of the type of argument.  In the case of clearArray, $1 is the passed in scalar array.</p>

<p>If you pass an <var>@array</var> to a function where a <var>$scalar</var> is expected then the <var>@array</var> will be 
converted to a scalar string representing the array.   All of the information in this section applies for %hashes as well.</p>

<h3>Recursion</h3>

<p>Sleep subroutines allow for recursion.  A recursive function is a function that calls itself.  An example of a recursive 
subroutine is factorial:</p>

<pre>sub fact
{
   if ($1 == 0) 
   { 
      return 1; 
   }

   return $1 * fact($1 - 1)
}</pre>

<h3>Inline Subroutines</h3>

<p>An inline subroutine is Sleep's solution to the macro.  An inline subroutine executes within the current function context as if it manually
existed there.  Local and closure variable scopes are shared with the current function.  Any attempt to yield, return, or callcc a value from an 
inline function will directly affect the parent.</p>

<p>Parameters passed to inline subroutines are numbered from <var>$1</var> ... <var>$n</var>.  <var>$this</var> and friends refer to the current
function and not the inline function.</p>

<p>Inline functions have utility for abstracting complex callcc, yield, or return behavior.  They are declared with the inline keyword.</p>

<pre>inline printx
{
   println("\$x is $x");
}

sub foo
{
   local('$x');
   $x = 0x31337;
   printx();
}</pre>

<p>Inline subroutines do not return values themselves.  Any attempt to use an inline function call in
an expression will result in <var>$null</var>.  Any attempt to use an inline function call that saves function state (yield, callcc) will result
in an unusable continuation.</p>

<h3>Nesting Subroutines</h3>

<p>Everything in sleep is evaluated in a (semi) straight forward manner.  When sleep executes a statement that consists of the 
keyword sub, followed by a name, and then a block of statements it puts the subroutine into the environment.  It is possible to 
nest subroutines within eachother or declare a different version of the same subroutine based on a conditional.</p>

<pre>if ($favorite eq "red")
{
   sub favoriteColor
   {
      return "my favorite color is red";
   }
}
else
{
   sub favoriteColor
   {
      return "I don't know what my favorite color is";
   }
}</pre>

<p>If <var>$favorite</var> is equal to "red "initially then the subroutine favoriteColor will be declared as a subroutine that 
returns "my favorite color is red".   Otherwise the subroutine favoriteColor will be declared as a subroutine that returns "I 
don't know what my favorite color is".</p>

<h2><a name="6">Arrays</a></h2>

<p>An array is a variable that holds a bunch of variables.  Arrays reference variables in numerical order.  So each variable in 
the array has an index (or position).  Arrays in sleep always begin with the @ at symbol.   This goes for referencing array 
elements individually and referencing the array as a whole.</p>

<pre>$x = 3;
@foo[0] = "Raphael";
@foo[1] = 42.5;
@foo[2] = "Donatello";
@foo[$x] = "Michelangelo";</pre>

<p>The above sets index 0 .. 2 of <var>@foo</var> to various values.  <var>$x</var> is evaluated in the last line and 
<var>@foo[3]</var> is set to "Michelangelo".  <var>@foo[3]</var> is now equivalent to a normal string scalar that has the value 
"Michelangelo".</p>

<p>When referencing an array with the index operator, it is acceptable to use negative indices.  For example to reference the
last element of <var>@foo</var> one could use <code>@foo[-1]</code>.  Many array functions normalize negative indices as well.</p>

<p>Arrays can be assigned to each other as well.   As stated in the Scalars section assigning an array to another array just 
copies the reference.   Both <var>@array</var>'s will point to the same data.  A change in one array will affect the other 
array.</p>

<p>The function <code>size(@array)</code> takes an array as a parameter and returns the total number of elements in the 
array.</p>

<p>To remove an element from an array use the remove function i.e. <code>remove(@array, $scalar)</code></p>

<p>Many arrays returned by built-in functions may be read only.  As such code that changes the array will have no effect on 
it.</p>

<h3>Foreach Loops</h3>

<p>Sleep provides a construct for easily looping through all of the elements in an array.  This is the foreach loop.</p>

<pre>foreach <b>$scalar</b> (<b>@array</b>)
{
   <b>commands</b>
}</pre>

<p>The foreach loop above iterates through each element in <var>@array</var>.  For each element in <var>@array</var>, the element 
value is set to <var>$scalar</var>.  Accessing <var>$scalar</var> is the same as accessing the specific element in the array.</p>

<p>Specifying a <var>%hash</var> in place of an <var>@array</var> will cause the foreach loop to iterate through the keys of 
<var>%hash</var>.  Foreach also has a second syntax:

<pre>foreach <b>$index</b> =&gt; <b>$value</b> (<b>source</b>)
{
   <b>commands</b>
}</pre>

<p>The foreach loop above will loop through the source (either an <var>@array</var> or a <var>%hash</var>).  The index of the 
source will be assigned to the scalar on the left.  The value of the source will be assigned to the scalar on the right.</p>

<p>Within a foreach loop most functions that modify the structure of <var>@array</var> are not allowed.  This includes add(), 
remove(), removeAt(), push(), pop() etc.  An attempt to modify the structure of @array during a foreach loops execution will 
result in a script warning.</p>

<p>The current element of a foreach loop can be removed by calling <code>remove()</code> with no parameters.  This only works 
when iterating over an <var>@array</var>.</p>

<p>Foreach loops can also iterate over closures.  This use of foreach loops is described when closures and coroutines are
described in the <a href="#10a">closures section</a>.</p>

<h3>Arrays as Stacks</h3>

<p>A stack is a data structure that has a push and pop operation.  Push puts data on top of the stack.  Pop takes data off the 
top of the stack.   Sleep arrays can be used as stacks.</p>

<pre>push(@array, "some data");

$value = pop(@array);</pre>

<p>In the first line the string "some data" is pushed on top of the array <var>@array</var>.  In the second line "some data" is 
popped off of the stack and returned by the function pop().   <var>$value</var> now contains the value "some data".</p>

<h3>Tuple Assignment</h3>

<p>To quickly assign elements of an array to scalars specified in a tuple use:</p>

<pre>($x, $y, $z) = @array;</pre>

<p>In the above example, <var>$x</var> will be set to the first element in <var>@array</var>, <var>$y</var> will be set to the 
second element, and <var>$z</var> will be set to the third element.</p>

<p>If there are not enough values in <var>@array</var> for all of the specified scalars then the remaining scalars will be set to 
<var>$null</var>.</p>

<P>If the value on the right hand side of the = assignment is not an array, then the above will act exactly as if <var>$x</var>, 
<var>$y</var>, and <var>$z</var> had been assigned to the specified value individually.</P>

<p>Assignment operations work with tuple assignment as well.  i.e.:</p>

<code>($x, $y, $z) += 3; # add 3 to $x, $y, and $z</code>

<p>You can also special a right hand side array with an assignment op.  In this case each value
of the right hand side array will be applied to the corresponding value within the tuple:</p>

<code>($x, $y, $z) *= @(2, 3, 4); # $x = $x * 2; $y = $y * 3; etc..</code>

<h4>Expand Array</h4>

<p>Assignment operators used in conjunction with tuples have one special case.  This is the
array expansion case.  When a single array is specified within the tuple then the array values
are expanded within the tuple as if you had type <code>(@array[0], @array[1], ...)</code>.  The
rest of the rules for tuple assignment apply from this point out.  This has some neat implications.
For example to add two arrays:</p>

<pre>@a = @(1, 2, 3);
@b = @(4, 5, 6);
(@a) += @b;</pre>

<p>The value of <var>@a</var> is now: @(5, 7, 9).</p>

<h3>Sorting</h3>

<p>Sleep includes functions for sorting arrays.  You can sort arrays numerically (double or int variety), or alphabetically.  To 
sort an array in sleep:</p>

<pre>@sorted = sorta(@array);</pre>

<p>The above sorts the array <var>@array</var> alphabetically.  To sort an array of integer scalars use 
<code>sortn(@array)</code>, to sort an array of double scalars use <code>sortd(@array)</code>.</p>

<p>You can also define your own custom sorting criteria using the sort() function.</p>

<pre>sub mysort
{
   if ($1 lt $2) { return -1; }
   if ($1 eq $2) { return 0; }
   if ($1 gt $2) { return 1; }
}

@sorted = sort(&mysort, @array);</pre>

<p>The above is equivalent to the first sorting example.  The code snippet sorts @array alphabetically.  The subroutine mysort is 
the custom sorting criteria.  All the sorting decisions are made by the subrouting mysort.  To define your own mysort simply make 
it return a value less than 0 if $1 is less than $2.  If $1 is equal to $2 make your mysort return 0.  If $1 is greater than $2 
then make your mysort return a value greater than 0.</p>

<p>The function sort takes two arguments.  A function handle and an array.  A function handle is a way of passing a subroutine as 
an argument in sleep.  To specify a function handle simply append the subroutine name to the & ampersand symbol.</p>

<h4>Sorting Operators</h4>

<p>Sleep defines two operators to assist with sorting.</p>

<table class="simple2" width="90%">
 <tr>
  <th width="240">Operator</th>
  <th>Description</th>
 </tr>  
 <tr>
  <td>$a cmp $b</td>
  <td>returns a value &gt; 0 if $a is greater than $b, a value &lt; 0 if $a is less than $b, and 0 if $a is equal to $b.  The cmp
      op performs a string comparison.</td>
 </tr>
 <tr>
  <td>$a &lt;=&gt; $b</td>
  <td>returns a value &gt; 0 if $a &gt; $b, a value &lt; 0 if $a &lt; $b, and 0 if $a == $b.  The &lt;=&gt; op performs a numerical
      comparison.</td>
 </tr>
</table>

<p>These functions are useful if you would like to easily implement your own sorting function.  For example to implement a case
insensitive sort:</P>

<pre>@array = @("Jill", "Jack", "BoB", "iReNE", "aDaWG");

sub my_sort
{
   return lc($1) cmp lc($2);
}

sort(&my_sort, @array);

printAll(@array);</pre>

<h3>Multidimensional Arrays</h3>

<p>Sleep arrays are just arrays of scalars.  It is possible for one of the elements of a scalar array to contain another scalar 
array (or hash for that matter).  The following sets up a multidimensional array:</p>

<pre>@data = @(
          @("a", "b", "c"),
          @(1, 2, 3, 4),
          @('.', '!', '#', '*')
       );</pre>

<p>In the example above @data is an array of arrays.  To access an individual element of @data:</p>

<pre>$temp = @data[2][3]; # $temp is now '*'</pre>

<p>The array from the first example could have also been setup with the following code:</p>

<pre>@data[0][0] = "a";
@data[0][1] = "b";
@data[0][2] = "c";
@data[1][0] = 1;
@data[1][1] = 2;
@data[1][2] = 3;
@data[1][3] = 4;
@data[2][0] = '.';
@data[2][1] = '!';
@data[2][2] = '#';
@data[2][3] = '*';</pre>

<p>There is no limit to how many levels deep your arrays/data structures can go.  Levels do not need to be the same size.</p>

<h2><a name="7">Hashes</a></h2>

<p>Hashes are a special scalar type that can hold a bunch of variables as well.  Unlike arrays hashes reference variables with a 
key.   Each variable in the hash has a unique key associated with it.  Hashes in sleep always begin with the % at symbol.   This 
goes for referencing hash elements individually and referencing the hash as a whole.</p>

<pre>$x = 3;
%foo["name"] = "Raphael";
%foo["job"]  = "wasting time";
%foo[$x]     = "Michelangelo";</pre>

<p>The above associates the key "name" with "Raphael" inside of %foo.  The key "job" is associated with "wasting time", and the 
key 3 is associated with "Michelangelo".  It is worth noting that the keys "3" and 3 are equivalent.  Keys to sleep hashes are 
always treated as strings.</p>

<p>Hashes can be assigned to each other as well.   Similar to assigning an array to another array, assigning a hash to another 
hash just copies the reference.  Both %hashe's will point to the same data.  A change in one hash will affect the other hash.</p>

<p>Many hashes returned by built-in functions may be read only.  As such code that changes the hash will have no effect on 
it.</p>

<p>To obtain an @array of all of the keys in a hash you can use the keys() function with the %hash as the parameter.   To remove 
a value from a hash you can use remove(%hash, "value").</P>

<p>To remove a key key from a hash simply set the value to $null.</p>

<h3>The Key/Value Operator</h3>

<p>Sleep has a literal form for dictionary data structures (hashes).  To construct a hash in place use a % followed
by a comma separated list of key/value pairs enclosed in parantheses.  i.e.</P>

<pre>%hash = %(key1 => "this is a value", key2 => 3 * (9 % 7));</pre>

<p>The => is the key/value pair operator.  The key/value pair operator can be used with special functions to 
specify a key/value pair.  The left hand side is never evaluated.</p>

<p>Sleep subroutines (and closures) can receive named parameters using the key/value operator.  When a named 
parameter is specified the left hand side must be equivalent to the variable to be installed into the local
environment of the called subroutine.  Within a subroutine @_ and $1, $2, ... are not affected by a key/value
argument.  The named parameter is simply available for immediate use.</p>

<pre>sub blah
{
   println("My name is $first $last $+ , and I like $1");
}

blah($first => "Raphael", $last => "Mudge", "ice cream!!!");
blah("ice cream!!!", $first => "Raphael", $last => "Mudge");
blah($first => "Raphael", "ice cream!!!", $last => "Mudge");</pre>

<p>The example above prints 'My name is Raphael Mudge, and I like ice cream!!!' three times.</p>

<p>Built-in functions that expect a key/value pair will accept either a key/value expression or a string of the form
"key=value".</p>

<h4>Scalar References</h4>

<p>Many times you may find yourself passing a key/value pair with the same key/value.  This is most often done to move
a scalar between scopes.  This is very common with fork, lambda, and let.  To save you some typing Sleep has a special
syntax for specifying a scalar be passed by name as a parameter.  Simply prefix the scalar with a backslash.</p>

<pre>sub foo
{
   local('$name');
   $name = "Raphael";
   bar(\$name);
}

bar
{
   println("Name is: $name");
}

foo();</pre>

<p>In the example above <var>$name</var> is local to <code>&amp;foo</code>.  Normally to pass <var>$name</var> into the this
scope of <code>&amp;bar</code> you would have to use <code>$name => $name</code>.  The scalar reference <code>\$name</code>
is equivalent to that expression.</p>

<h3>Multidimensional Hashes/Arrays</h3>

<p>Multidimensional hashes work exactly the same as Sleep arrays.  It is also possible to have an array of hashes, or a hash of 
arrays.  Sleep even allows these two data structures to be mixed and matched as you please.</p>

<pre>%hash = %(letters => @("a", "b", "c", "d"),
               names   => %(
                            rsm => "Raphael Mudge",
                            fvm => "Frances Mudge")
            );</pre>

<p>When a script tries to index to a level that is deeper than has been indexed prior Sleep will create a new hash/array as 
appropriate.  Sleep knows which new structure to create based on the variable at the beginning of the index chain.</p>

<p>The indexing operator can be applied to function calls, expressions wrapped in parentheses, and $scalars.  When the indexing 
operator is called on these items, Sleep will assume that there is either a hash or array data structure being referenced.  If 
a script attempts to index to a new level from this context then no new structure will be created and $null will be returned.</p>

<pre>$temp = split(' ', "A B C")[1]; # $temp is now "B"</pre>

<h2><a name="8">String manipulation</a></h2>

<p>Sleep strings come in two varieties.  Literals and parsed literals.  A literal string is a string where what you type is 
exactly what you get.</p>

<pre>$name = 'The Simple Language for Environment Extension Purposes';</pre>

<p>A literal string is always enclosed in ' single quotes.  A parsed literal string is always enclosed in " double quotes.</p>

<pre>$name = "The Simple Language for Environment Extension Purposes";</pre>

<h3>Parsed Literals</h3>

<p>Parsed literals allow you to embed $scalar variables directly inside of them.  Variables inside of parsed literals are 
evaluated to their current value.</p>

<pre>$parsed = "The language is $name";
$normal = 'The language is $name';</pre>

<p>The scalar $parsed would now contain the value "The language is The Simple Language for Environment Extension Purposes".  
Where as the scalar $normal would now contain the value 'The language is $name'.</p>

<p>Parsed literals also have a special scalar $+.  The scalar $+ is a concatenation operator within parsed literals.  In case you 
want to combine two scalars within a parsed literal.</p>

<pre>$a = "Super";
$b = "man";
$value = "$a $+ $b";</pre>

<p>The scalar $value would have the value "Superman".</p>

<p>Wait, theres more.  Scalars inside of parsed literals also support some built in formatting.  You can format a scalar inside 
of a parsed literal as follows.</p>

<pre>$first = "John";
$last  =  "Doe";
$value = "$[10]first $[10]last";</pre>

<p>The scalar $value would have the value "John       Doe       ".   The number inside of the [ ] square brackets specifies the 
number of characters wide the scalar should be.  The scalar is typically padded with spaces to the right of the value.  If you 
specify a negative number the scalar will be padded with spaces to the left.</p>

<p>It is also possible to use an expression inside of the alignment [ ] square brackets. Expressions inside of the alignment [] 
square brackets may not include a reference to an array or hash index.</p>

<p>Parsed literals only evaluate $scalar values.  Parsed literals do not evaluate @array and %hash references or indices.</p>

<p>Characters within parsed literals can be escaped using the \ back slash character. The character immediately following a \ 
back slash is ignored during processing (and the initial back slash is removed).  Sometimes characters following backslashes have 
special meanings.  Initial special meanings include:</p>

<table class="simple2">
 <tr>
  <th>Escape</th>
  <th>Description</th>
 </tr>
 <tr>
  <td>\n</td>
  <td>newline character</td>
 </tr>
 <tr>
  <td>\r</td>
  <td>return character</td>
 </tr>
 <tr>
  <td>\t</td>
  <td>tab character</td>
 </tr>
 <tr>
  <td>\u####</td>
  <td>16 bit unicode character i.e. "\u0063" is "c"</td>
 </tr>
 <tr>
  <td>\x##</td>
  <td>8 bit character i.e. "\x6A" is "j"</td>
 </tr>
 <tr>
  <td>\\</td>
  <td>back slash \ character</td>
 </tr>
</table>

<p>Speaking of escapes, parsed literals allow two forms of character literals.  A <code>\x</code> followed by two hex nibbles specifies one character.  16-bit unicode characters can be specified with <code>\u</code> followed by four hex nibbles.</p>

<h3>Normalized Parameters</h3>

<p>Sleep has many functions for manipulating strings.  These functions work as you would expect.  For example:</p>

<pre>$x = left("this is a test", 4);</pre>

<p>The left 4 characters of "this is a test" are "this".  This is all well and good, but we have one other
trick up our sleeve.  Many of Sleep's string manipulation functions allow a negative index to be specified.  i.e.:</p>

<pre>$x = left("this is a test", -4);</pre>

<p>When a negative index is specified to a string manipulation function, the negative number will be normalized based on the length of the string.  Normalizing occurs by adding the length of the string to the negative number.  So the function above will return the string "this is a ".</p>

<h3>Regular Expressions</h3>

<p>Sleep includes built-in regular expressions.  Regular expressions are a powerful way to parse strings without having to write 
much code.  Regular expressions consist of defining a pattern.  Patterns can then be applied to a string to see if the string 
matches the pattern or to extract information from the string. Unfortunately regular expression pattern syntax is like a whole 
other language in of itself.  Have fun.</p>

<p>In this documentation a correctly formatted regular expression pattern is referred to as a <b>'pattern'</b>.</p>

<p>To test if a string matches a pattern in sleep you can use the ismatch comparison operator.</p>

<pre>if (<b>"my string"</b> ismatch <b>'pattern'</b>) { <b>commands</b> }</pre>

<p>To extract the "remembered" matches directly after an ismatch comparison (see <a href="#14">Appendix C -> Pattern Grouping</a>) you can use the
matched function.</p>

<pre>@array = matched();</pre>

<p>To simply extract "remembered" matches from a pattern (see <a href="#14">Appendix C -> Pattern Grouping</a>) you can use the matches 
function.</P>

<p>The ismatch comparison operator expects the specified pattern to match the entire string.  Sometimes it is helpful to
look for substrings that match the specified pattern.  For this purpose Sleep provides the hasmatch comparison operator.  
The hasmatch comparison continues to return true while the specified string has a substring that matches the specified 
pattern.</p>

<pre>while ('ABhCDEFeGHIJlKLMNlOPQRoST' hasmatch '[A-Z]{2}([a-z])[A-Z]{2}')
{
   @array = matched();
   print(@array[0]);
}</pre>

<p>The example above keeps looping while the specified string has substrings that match the pattern of 2 upper case letters, a 
lower case letter, followed by 2 upper case letters.  Once the last substring has been found, hasmatch returns false and 
the matcher is reset.</p>

<p>The &amp;matches function allows you to extract all of the substrings in "some string" that match the specified 
'pattern'.</p>

<pre>@array = matches("some string", <b>'pattern'</b>);</pre>

<p>Sleep also lets you split a string up using a regular expression pattern as the token delimeter.</p>

<pre>@array = split(<b>'pattern'</b>, "some string");</pre>

<p>Consequently the join function takes a string and an array as a paramter and joins the array together with the specified 
string.</p>

<pre>$value = join("with", @array);</pre>

<p>You can also use the replace function to replace text in a string that matches a certain pattern with some new text.</p>

<pre>$value = replace("the entire string", <b>'pattern'</b>, "replacement value");</pre>

<p>The above is equivalent to using:</p>

<pre>$value = join("replacement value", split(<b>'pattern'</b>, "the entire string"));</pre>

<h2><a name="9">Input/Output Capabilities</a></h2>

<p>The sleep IO capabilities allow you to read and write data from/to files, tcp sockets, and other processes.</p>

<p>To read a file into an array:</p>

<pre>$handle = openf("/etc/passwd");
@data = readAll($handle);
closef($handle);</pre>

<p>The first line of the above program opens the file /etc/passwd for reading.  The value returned by the openf function is an 
object scalar with information about the open file.  The function readAll() takes an object scalar returned by a sleep IO 
function.  All of the data is read from the file and then return as an array.  Finally the function closef closes the 
handle.</P>

<p>To read a line of text from an open file you would simply use the readln function.</p>

<pre>if (!-eof $handle) { $data = readln($handle); }</pre>

<p>The above would read one single line of text from the file.  The unary comparison operator eof checks whether or not the 
handle is at the end of the file.  If the handle is at the end of the file then there is no more data to be read.</p>

<p>Most functions can do without a $handle argument and just assume stdin/stdout.  In cases where a handle for the stdin/stdout 
is required use the getConsole() function.  The predicate operator -eof is one such case where a handle must always be 
specified.</p>

<p>Sleep I/O read functions return the empty scalar $null to indicate the read operation failed.</p>

<p>To write data to a file you have to first open the file for writing.</p>
   
<pre>$handle = openf(">>/etc/passwd");
println($handle, "raffi:x:0:0::/:/bin/sh");
closef($handle);</pre>

<p>The open function works much like redirecting files on the command line.  If you specify a filename by itself, the file will 
be open for reading.  If you specify >> two angle brackets then the file will be opened for writing in append mode.  If you 
specify a > single angle bracket then the file will be opened for writing in overwrite mode.  The function println takes a scalar 
object with a handle and a string to write as a parameter.  The newline character is automatically appended when using 
println.</p>

<p>The function print works much like the function println except it does not append a newline character to the written data.</p>

<p>Remember that sleep is a cross platform scripting language.  As a convention use the / forward slash character as a path 
separator so that your scripts will work in a platform neutral way.</p>

<h4>Unicode Support</h4>

<p>Sleep is unicode friendly.  &amp;println, &amp;print, &amp;readc, &amp;readln, and &amp;read will
convert read in data using the platforms default charset.  If this is a problem use &amp;readb and
&amp;writeb to read and write raw bytes from the handle.  To change the charset encoder/decoder for a 
handle use the &amp;setEncoding function.</p>

<h3>Callback Reading</h3>

<p>Another way of reading data from a scalar object with a handle is to use callback reading.  Callback reading is done with the 
read() function.</p>

<p>For example:</p>

<pre>sub myread { printf("Read $1"); }

$handle = openf("/etc/shadow");
read($handle, &myread);</pre>

<p>The read function takes two parameters.  A scalar object containing a io handle and a function handle.  In the example above 
the function handle is for the subroutine myread.  Each time a line of text is available to be read myread will be called with $1 
pointing to the io handle and $2 being the text read from the file.</p>

<p>This isn't very useful for reading from files but its necessary for reading from other data sources that might have a lot of 
time in between data being available.</p>

<h3>Sockets</h3>

<p>Sleep IO can be used to connect to hosts on the internet or your local network with its sockets functionality.  Using sockets 
is similar to working with files.  Except when a socket is opened it is opened for both reading and writing.  Writing to sockets 
and reading from sockets is exactly the same as files.</p>

<pre>$socket = connect("www.yahoo.com", 80);
println($socket, "GET /");
@data = readAll($socket);
closef($socket);</pre>

<p>The above example is a simple web client.  A socket is opened to www.yahoo.com on port 80.  A request is then made for the 
index page.  All of the data from the socket is then read into @data.  The socket is then immediately closed</p>

<p>Its usually a good idea to use callback reading with sockets.  The http protocol is a simpler protocol where a request is 
made, the data is returned, and then the socket is closed.  So using readAll is safe with http.  Other protocols are a little bit 
more interactive than http.</p>

<h3>Listening Sockets</h3>

<p>Sleep IO can also listen for a connection from a host.  Using a server socket is much like working with a normal socket.</p>

<pre>$socket = listen(31337, 60 * 1000, $host);
println("Received a connection from: $host");
@data = readAll($socket);
closef($socket);</pre>

<p>The above example listens for a connection on port number 31337.  If no one connects to port 31337 after 60,000ms or 60 
seconds then the socket will give up.  Once a connection is received the ip address of the connecting machine will be in the 
scalar $host.</p>

<p>If you don't want the socket to give up listening you can specify 0 as the timeout value.</p>

<h3>Processes</h3>

<p>External programs can be executed and communicated with via sleeps IO as well.  Reading from and writing to an executing 
process is the same as working with files or sockets.</p>

<pre>$process = exec("ls -al");
@data = readAll($process);
closef($process);</pre>

<p>Calling closef on a process will kill the process.  The above program executes the UNIX command ls -al which lists all of the 
files in the current directory with some details.</p>

<h4>Quick Execution</h4>

<p>Similar to Perl, Sleep also supports quick execution of a process via a string enclosed in backticks.  Any string enclosed in
backticks is evaluated (as if it was a parsed literal) and the contents is then executed.  The output of the executed command is
returned as an array.</p>  

<pre>foreach $file (`ls -1`)
{
   # do something with the file...
}</pre>

<p>Any errors from trying to execute the command are available via <code>&amp;checkError</code>.  If the process returns a non-zero
value, this will also be available with <code>&amp;checkError</code>.</p>

<h3>Buffers</h3>

<p>For those times when speed is a necessity Sleep provides the loveable byte buffer.  A buffer is simply
a segment of memory that can be written to (and eventually read from) using Sleep's I/O functions. 
Buffers are fast.  If there is a need to concatenate lots of data or to manipulate streams of data then
buffers are a must.</p>

<p>To allocate a buffer use the allocate function.  Buffers are initially write-only once allocated.</p>

<pre>$buffer = allocate(1024 * 10); # allocate a 10K buffer</pre>

<p>Once allocated this buffer can be written just like a file:</p>

<pre>println($buffer, "this is some text, in the buff!");
writeb($buffer, 33);</pre>

<p>Calling &amp;closef on a write-only buffer will turn it into a read-only buffer.  Once a writeable 
buffer has been closed, it can then be read from.</p>

<pre>closef($buffer);
$string = readln($buffer);
$byte   = readb($buffer, 1);</pre>

<p>Calling &amp;closef on a read-only buffer will deallocate the buffer's resources.</p> 

<b>Example:</b>

<p>To encrypt a file with a simple XOR scheme:</p>

<pre># read the file in
$input = openf(@ARGV[0]);
$data = readb($input, lof(@ARGV[0]));
closef($input);

# encrypt the contents of the file...
$buffer = allocate(strlen($data));

for ($x = 0; $x < strlen($data); $x++)
{
   writeb($buffer, chr(byteAt($data, $x) ^ 0x34));
} 

closef($buffer); # buffer is readable now..
$data = readb($buffer, strlen($data));

# write the file out
$output = openf(">" . @ARGV[0]);
writeb($output, $data);
closef($output);</pre>

<h3>Pipes</h3>

<p>Sometimes it is helpful for a script to execute multiple tasks concurrently.  Each task being executed at the same time by a 
given program is usually referred to as a thread.  Sleep can execute multiple threads with the function 
<code>&amp;fork()</code>.</p>

<p>To launch a new thread using fork:</p>

<pre>sub my_taskA
{
   for ($x = 0; $x < 100; $x++)
   {
      println("Task A: $x");
   }
}

sub my_taskB
{
   for ($x = 0; $x < 100; $x++)
   {
      println("Task B: $x");
   }
}

fork(&amp;my_taskA);
fork(&amp;my_taskB);</pre>

<p>When the above script executes the subroutines <code>&amp;my_taskA</code> and <code>&amp;my_taskB</code> will both execute 
at the same time.  The output will be a seemingly random mix of Task A counting to 100 and Task B counting to 100.  This is 
because Java lets <code>&amp;my_taskA</code> run for a little while and then it lets <code>&amp;my_taskB</code> run for a 
little while.</p>

<p>When a Sleep script forks, a completely new script environment is created.  This new script environment is mostly isolated
(see <i>*</i>) from its parent script environment.  No variables that were visible or available in the parent environment are
available in the fork.  All forked scripts are isolated from eachother as well.  All subroutines, operators, and predicates
available in the parent are available to the child.</p>

<p>You may be asking, if no variables are visible, then how does the parent script communicate with its forked children?</P>

<p>The function <code>&amp;fork()</code> returns a <var>$handle</var> similiar to any of the Input/Output functions for opening 
files, executing processes, and connecting to servers.  The parent script can read from and write to the <var>$handle</var> 
returned by <code>&amp;fork()</code> using any of Sleep's built-in IO functions.</p>

<p>Inside each of the children there is a variable called <var><b>$source</b></var>.  The variable <var>$source</var> is an 
input/output handle as well.  Anything written to the <var>$handle</var> returned by <code>&amp;fork</code> can be read from 
<var>$source</var>.  Conversely anything written to <var>$source</var> within the child forked script can be read from the 
<var>$handle</var> returned by <code>&amp;fork</code>.  This is called a pipe.</p>

<p>Once complete a forked script may return a value.  To intercept this value use the <code>&amp;wait</code> function.</p>

<p><i>*</i>: It is possible to pass an initial set of values to the <code>&amp;fork</code> function.  Care should be taken
when choosing to pass initial values.  Arrays, hashes, and object scalar data passed as initial values are visible in both
the main script environment and the forked script environment.  Changes in one environment will reflect in the other.  To
compound things there is no synchronization to protect against both environments using the data at the same time.  In short,
if you pass an initial value to a fork, discipline yourself to only manipulate that data from one environment.</p>

<p>Sleep does provide semaphores as a synchronization primitive that can be used to lock critical sections of 
code.  Semaphores can be used to control resources that forks attempt to access.</p>

<h3>Working with Binary Data</h3>

<p>Sleep also has the ability to work with binary data.  A byte of data is generally represented as a string of one character 
in Sleep.  An array of bytes is a Sleep string.</p>

<p>The following is an example of a file copy script:</p>

<pre># copy.sl [original file] [new file]

$in = openf(@ARGV[0]);
$data = readb($in, lof(@ARGV[0]));

$out = openf(">" . @ARGV[1]);          
writeb($out, $data);

closef($in);
closef($out);</pre>

<p>The above example uses the readb and writeb functions to read and write binary data.  Sleep also has functions for creating 
byte strings and extracting data from them:</p>

<pre>For example to write several different data types to a binary file:</pre>

<pre>$out = openf(">mydatafile");
bwrite($out, 'CidZl', "A", 42, 3.5, "hehe this is a string", 1234567890);</pre>

<p>To read this data back in:</p>

<pre>$in = openf("mydatafile");
($char, $int, $double, $string, $long) = bread($in, 'CidZl');

println("char   data is: $char");
println("int    data is: $int");
println("double data is: $double");
println("string data is: $string");
println("long   data is: $long");</pre>

<p>You may notice the 'CidZl' parameter for &amp;bread (mmm bread) and &amp;bwrite.  This parameter is a string specifying the 
format of the binary data.  This parameter is used in the &amp;pack and &amp;unpack functions as well.  Information about 
this format can be found in <a href="#16">Appendix E - Binary Data Format Strings</a>.</p>

<h3>Catching I/O Errors</h3>

<p>All I/O open functions have potential to fail.  A file might not exist, the operating system might not be able to execute a 
command, or a hostname might not be found when trying to open a connection.  To check if an error occurred when opening an IO use 
the checkError() function.</p>

<pre>$handle = openf("this_file_does_not_exist");
   
if (checkError($error))
{
   println("Could not open file: $error");   
}</pre>

<p>checkError() returns the latest error message since it was last called.  When checkError() is called the 'current' error 
message is cleared.   A scalar passed to checkError() as  an argument will have the value of the 'current' error message placed 
into it.  In the above example checkError sets the value of $error to be a message stating why the file could not be opened.</P>

<h2><a name="10">Working with Objects</a></h2>

<p>A new feature in Sleep is the haphazard object extensions for Sleep (HOES).  HOES adds some new syntax for creating, 
accessing, and working with Java objects.  This interface is brand new and is geared towards experienced programmers.  If you 
are comfortable with the Java API you may really enjoy playing with HOES.</p>

<h3>Object Creation</h3>

<p>Objects are created using HOES expressions.  The following example creates an instance of the StringTokenizer class:</p>

<pre>$scalar = [new java.util.StringTokenizer:"this is a test"];</pre>

<p>You may notice that the package name is specified.  You can avoid specifying full package names by importing packages.  The 
syntax for importing packages is exactly the same as in Java.  For example:</p>

<pre>import java.util.*;

$scalar = [new StringTokenizer:"this is a test"];</pre>

<p>You can also import specific packages i.e. <code>import java.util.StringTokenizer;</code>.  Objects can be assigned to 
$scalar variables.  Once instantiated they can be operated on as Sleep scalars using Sleep constructs or as Java objects using 
object expressions.</p>

<h3>Object Expressions</h3>

<pre>[object message: parameter, parameter, ...];</pre>

<p>HOES object expressions are contained inside of square brackets '[]'.  Typically the first parameter in an expression is the 
object being operated on.  The second parameter is the message being passed to the object.  A message in HOES speak is 
equivalent to a Java method/function name.  Parameters specified after the message followed by a colon ':'.   Each parameter 
is separated by a comma ','.</p>

<h4>Object Expression Examples</h4>

<pre>[System gc];</pre>

<p>The above calls the method gc in the class java.lang.System.  Classes inside of the package java.lang are imported for you.  
A full path to a class name can be specified in object expressions with the period '.' separator i.e:</p>

<pre>$ctime = [java.lang.System currentTimeMillis] / 1000;</pre>

<p>In the above example the message <var>currentTimeMillis</var> is retrieved from <var>java.lang.System</var>.  This example 
also illustrates an object expression being used within a normal Sleep expression.</p>

<p>You can not use a period '.' to access a message/field in an object i.e.:</p>

<pre><font color="red"><s>[System.out println: "test" ];</s> # wrong!</font></pre>

<p>To correctly access a message/field that is multiple levels deep:</p>

<pre>[[System out] println: "test" ]; # correct</pre>

<p>The above is equivalent to the Java call: <code>System.out.println("test");</code>.  The above example also illustrates that 
object expressions can be nested.  Another thing to note is that <code>[System out]</code> accesses the field <var>out</var> 
within the <var>System</var> class.  In HOES methods and fields are both accessed the same way.  The only difference is fields 
cannot accept parameters.</p>

<p>Scalars and expressions can be operated on within object expressions:</p>

<pre>$value = ["this is a String" lastIndexOf: "i" ];</pre>

<p>The above is equivalent to <code>"this is a string".lastIndexOf("i")</code> in Java.  Numbers are treated as there wrapper 
java objects.  For example a double scalar is converted into a Double object for use in object expressions:</p>

<pre>$value = [3.45 isNaN];</pre>

<p>The above calls the method/message isNaN on the Double value 3.45.  It is worth noting that fields/methods that return a 
Java boolean type will end up being turned into a string scalar in Sleep.  Basically a boolean value from a Java method will be a
string value of "true" or "false".</p>

<p>The following is a more in-depth example of object expressions in action:</p>

<pre>import java.util.*;

$scalar = [new StringTokenizer: "this is a test", " "];

while ([$scalar hasMoreTokens])
{
   println("Token: " . [$scalar nextToken]);
}</pre>

<p>The above example breaks the string "this is a test" down by the delimeter " " using the java.util.StringTokenizer 
class.</p>

<h4>Using 3rd Party Jars</h4>

<p>Sleep can also import packages from jar files not loaded in the classpath.  For example to use the JDOM XML API in
a Sleep script one would:</p>

<pre>import org.jdom.*        from: jdom.jar;
import org.jdom.input.*  from: jdom.jar;
import org.jdom.output.* from: jdom.jar;

# load the document in
$builder  = [new SAXBuilder];
$document = [$builder build: @ARGV[0]];

# print the document out.
$output   = [new XMLOutputter: [Format getPrettyFormat]];
[$output output: $document, [System out]];</pre>

<p>Sleep will try to find the specified jar file (i.e. jdom.jar) using the Sleep classpath.  This value is the
sleep.classpath accessible as systemProperties()["sleep.classpath"].</p>

<p>If the jar filename includes spaces, you can surround it with single or double quotes.</p>

<h4>Class Literals</h4>

<p>Sleep has a special literal form for specifying Java classes within scripts.  The hat symbol followed by a string is 
expanded into the appropriate class using the current list of imports at script compile time.  As an example <code>^String</code>
expands to the result of <code>[Class forName: "java.lang.String"]</code>.  Class literals can be used to compare scalar types
against eachother, to specify a desired class in a casting function, and more.</p>

<p>Inner classes are referenced with a dollar sign between the parent class and the inner class name i.e.:
<code>^Map$Entry</code> references the Entry class that belongs to the Map class.</p>

<p>For example to check if an exception is an IOException before acting on it:</p>

<pre>import java.io.IOException;

$handle = openf("fjosfjs");
if (checkError($error) && $error isa ^IOException)
{
   println("Could not open file: " . [$error getCause]);
}</pre>

<p>The <code>isa</code> predicate is used to check if the value on the left hand side is an instance of the class on the 
right hand side.  It is analagous to Java's instanceof predicate.</p>

<h3><a name="interfaces"></a>Sleep Interfaces</h3>

<p>A neat feature of HOES is how interfaces can be quickly and easily created and passed to Java objects.  A Java interface
defines methods that a Java class should implement to facilitate interacting with certain objects.  </p>

<pre>import javax.swing.*;
import java.awt.*;

$frame = [new JFrame:"Test"];
[$frame setSize:240, 120];
[$frame setDefaultCloseOperation: [JFrame EXIT_ON_CLOSE]];

$button = [new JButton:"Click me"];

[[$frame getContentPane] add:$button];

[$frame show];

$clicked = 0;

sub button_pressed
{
   # $0      = the message passed i.e. "actionPerformed"
   # $1 .. n = the message parameters i.e. a java.awt.event.ActionEvent object

   $clicked++;

   [[$1 getSource] setText:"Clicked $clicked time(s)"];
}

[$button addActionListener:&button_pressed];
</pre>

<p>This script example creates a window with a button on it.  The button is updated to 
show a click count each time it is clicked.   Closures can be specified where an object implementing a certain interface is 
asked for.  When an object tries to call a "method" on an interface subroutine, the closure is called with the method name 
specified as a 0th parameter.  The parameters 1..n are the actual parameters passed with the message.</p>

<p>Above, the <var>&button_pressed</var> subroutine is acting as a java.awt.event.ActionListener interface.  The 
only message passed to ActionListener interfaces is the actionPerformed message.  The button_pressed subroutine is passed as a 
closure parameter in this line: <code>[$button addActionListener:&button_pressed];</code>.</p>

<p>Sleep backed instantiations of Java interfaces can also be created with the <code>&amp;newInstance</code> function.</p>

<p>Any uncaught exceptions originating from a Sleep script will bubble up to the Java caller of the Sleep interface.</p>

<h3>Scalar Conversions</h3>

<p>Sleep automatically converts scalar data into the appropriate Java types when necessary.  Sleep strings map easily to Java 
strings.  Sleep object scalars map exactly to the Java objects they hold.  Sleep numbers map to Java numbers naturally.  The 
Java type boolean is represented as a 1 (true) and a 0 (false) in Sleep.</p>

<p>Sleep will map any Java value returned by a HOES expression to the most appropriate Sleep scalar type.  If a HOES 
expression returns a Java array, Sleep will automatically convert the Java array into an @array with appropriate 
dimensions.</p>

<p>If a function requires a Java array, Sleep will do the best it can to convert an @array into a Java array.  This automatic 
conversion is limited to 1-dimensional arrays.  Sleep will look at the first non-null element of @array and use that to 
determine what Java type the array should be.  If the first element is an int, a double, or a long Sleep will create a
Java array of the same type coercing all values to fit into that mold as well.  Otherwise Sleep will assume the array is an 
array of objects.  It is imperative that object arrays have a consistent type throughout.</p>

<p>If the automatic casting is not enough, Sleep includes a <code>&amp;cast</code> function.  The <code>&amp;cast</code> 
function will cast an @array into any Java type.  Dimensions can be specified as well.  For example:</p>

<pre>@array = @("a", "b", "c", "d", "e", "f");
$casted = cast(@array, "*", 2, 3); # create a 2x3 array</pre>

<p>The example above creates an object scalar <var>$casted</var> that references a 2x3 array of Strings.  The elements of 
$casted are (("a, "b", "c"), ("d", "e", "f")).  Note that the @array argument passed to <code>&amp;cast</code> is flattened 
prior to casting.</p>

<p>Sleep will also convert a Sleep array scalar into a java.util.List if need be.  Likewise a Sleep hash scalar
is converted into a java.util.Map if a function requires such an argument.</p>

<h3>Catching Exceptions</h3>

<p>Often times Java API's acessed via HOES can throw an "exception".  Exceptions are a mechanism used to notify programs that some type of error has occured.  You can check for an exception using the <code>checkError($scalar)</code> function.  The value returned by checkError() will be the actual Exception object.  This object can be used within object expressions.</p>

<p>If you prefer a more Java-esque method of handling exceptions, Sleep does have a <a href="#throw">try/catch/throw</a> mechanism that can
be utilized.</p>

<h2><a name="10a">Sleep Closures</a></h2>

<p>Closely coupled with HOES is the concept of Sleep closures.  A closure in sleep is a block of code that contains its own 
lexical scope.  i.e. there are variables specific to each closure instance.</P>

<p>Subroutines in Sleep are considered named closures.  They are accessed and passed as arguments using their names.  i.e 
<var>&my_subroutine</var>.</p>

<p>To create a simple closure:</p>

<pre>$closure = {
   println("My name is: $1"); 
};

[$closure: "Raphael"];</pre>

<p>The output of the above is:</p>

<pre><b>My name is: Raphael</b></pre>

<p>Closures take arguments just like subroutines.  The first parameter is $1, the second parameter $2, so on and so forth.  
Subroutines can also be accessed using HOES syntax:</p>

<pre>sub my_sub {
   println("My name is: $1");
}

[&my_sub: "Raphael"];</pre>

<p>The $0 parameter of a closure call is the message/method name passed to the closure.</p>

<h3>Closure Scope</h3>

<p>Closure instances have their own variable scope.  To declare a new closure instance and some of its initial values you can 
use the lambda function:</p>

<pre>$myfunc = lambda({
   println("My initial name is $name");
},  $name => "Raffi");

[$myfunc];</pre>

<p>The above creates a new closure assigned to $myfunc.  The initial value of $name inside of the closure scope is "Raffi".</p>

<p>To explicitly declare a value or set of values to be within a closure scope use the function <code>this()</code>>. i.e.</p>

<pre>$myfunc = {
   this('$a $b $c @array %hash');
   # do stuff...
};</pre>

<p>In the above closure the variables <var>$a, $b, $c, @array,</var> and <var>%hash</var> are all available when 
<var>$myfunc</var> is executed.  They are not available outside of the <var>$myfunc</var> scope.</p>

<p>Another special variable available within closures is the <var>$this</var> variable.  <var>$this</var> refers to "this" 
closure.</p>

<h4>Indexing Closures</h4>

<p>The index operation applied to a closure obtains a value from the closure's "this" scope.</p>

<pre>sub life_universe_and_everything
{
   this('$answer');
   $answer = 42;
}

life_universe_and_everything(); # nothing is available until 
                                # the function actually executes

println("What is the meaning of it all? " . &life_universe_and_everything['$answer']);
&life_universe_and_everything['$question'] = "Unknown?!?";</pre>

<h3>Accumulator Example</h3>

<p>This first example is a Sleep Accumulator Generator.  An Accumulator Generator is a function that takes a parameter
returns a function that increments the accumulator generator parameter by a parameter specified to the generated function.</p>

<pre>sub accum 
{
   return lambda(
          {
             $i = $i + $1; 
             return $i;
          },  $i => $1);
}

$accum_a = accum(3);
println("a: " . [$accum_a: 1]);
println("a: " . [$accum_a: 1]);

$accum_b = accum(30);
println("b: " . [$accum_b: 2]);
println("b: " . [$accum_b: 2]);</pre>

<p>The output of the above is:</p>

<pre><b>a: 4
a: 5
b: 32
b: 34</b></pre>

<p>Notice that two accumulators were generated and assigned to <var>$accum_a</var> and <var>$accum_b</var>.  The 
<var>$accum_a</var> accumulator starts out with an initial value of 3.  The first call against it increments it by 1 making the 
value within the accumulator 4.  The next call increments it by 1 making for an internal value of 5.</p>

<h3>Closures as Pseudo Objects</h3>

<p>Closures can also accept a "message" parameter just like HOES objects.  i.e.:</p>

<pre>[$closure message: arg1, arg2, ... ];</pre>

<p>This message parameter is available as the variable <var>$0</var>.  Using $0 it is possible to make closures that behave 
much like objects.  The following example generates a Stack data structure closure:</p>

<pre>sub BuildStack
{
   return {
             this('@stack');

             if ($0 eq "push") { push(@stack, $1); }
             if ($0 eq "pop")  { return pop(@stack); }
          };
}

$mystack = BuildStack();  # construct a new stack closure...
[$mystack push: "test"];  # push the string "test" onto the stack

println("Top value is: " . [$mystack pop]); # pop the top value off of the stack and print it</pre>

<p>The above is an example of a subroutine that generates a closure that emulates a Stack object.  Notice that the push and pop 
calls on this closure are accessed just like a normal Object would be via HOES.</p>

<h3>Coroutines</h3>

<p>Another nifty trick of Sleep closures is that they can also be used as coroutines.  A coroutine is a function
with multiple points of entry (rather than just a single point of entry as is common with subroutines).</p>

<h4>The Yield Command</h4>

<p>Sleep implements coroutines with a <b>yield</b> command.  The yield command causes the current closure to 
stop executing, save its current execution state (including local variables) and to return a value.  In short
yield works just like return except it saves the current execution state.</p>

<p>What separates yield from return is next time the yielded closure is called, the saved execution state will be
loaded (including local variables) and execution of the coroutine will resume from the place where yield was 
last called.</p>

<p>When the return command is used or the end of the closure is reached, the saved context will be discarded.</p>

<h4>Generators with Coroutines</h4>

<p>One usage of a coroutine is to easily generate a sequence of numbers i.e.:</p>

<pre>$generator = {
   this('$counter');

   for ($counter = 0; $counter < 1000; $counter++)
   {
      yield $counter;
   }

   return $null;
};</pre>

<p>The above stores a coroutine into $generator.  The first time $generator is called a 0 will be returned.  The second time $generator will
return a 1.  So on and so forth until $null is finally returned.</p>

<p>Foreach loops can be used to iterate over a closure.</p>

<pre>foreach $value ($generator)
{
   println("Value is $value");
}</pre>

<p>The above would iterate over $generator until it returned $null.  The output would be:</p>

<pre>Value is 0
Value is 1
...
Value is 998
Value is 999</pre>

<p>This use of foreach is a limited version of the assignment loops using the extended while syntax.  Assignment loops
evaluate an expression each iteration of a loop where as foreach is iterating over a closure reference.  The difference is
pretty much in the implementation, the end result is the same.</p>

<h4>The Callcc Command</h4>

<p>Similar to coroutines are continuations.  A paused function object can be thought of as the future stuff to execute (or the
continuation) of the function.  The callcc command syntactically resembles yield and return except a function parameter is required.</p>

<p>callcc will save the current function state into a object.  The specified function will the be called with the current function continuation
as a parameter.  Control flow will be moved to the specified function.  callcc can be thought of as a functional-level goto.</p>

<p>The syntax for callcc is:</p>

<p><code>callcc <b>closure</b></code>;</p>

<p>The return value of the specified closure will be the return value of the current function.  The specified closure receives the continuation of 
the current function as the <var>$1</var> parameter.</p>

<p>The following is a simple example of callcc demonstrating the producer/consumer problem:</p>

<pre>$buffer  = $null;

sub produce {
   for ($x = 0; $x < 3; $x++) {
      println("Produce: $x * 3");
      $buffer = $x * 3;
      callcc &consume;
   }
}

sub consume {
   println("Consume: $buffer");
   callcc $1; # resume the calling function
}

produce();</pre>

<p>Callcc and yield use the same internal mechanisms.  The practical difference between callcc and yield is that callcc expects a function parameter and this
function parameter is immediately invoked with the saved state of the calling function.</p>

<h2><a name="11">Function Library</a></h2>

<p>This appendix is a list of the application neutral built-in functions for sleep.  I expect this list to grow as time goes on.  
Much of the functionality for sleep should in theory come from the bridges provided by the application author.</p>

<h3>Conventions</h3>

<table class="simple2">
 <tr>
  <td>$</td>
  <td>add(@array, $scalar, [index])</td>
 </tr>
</table>

<p>The $ to the left of the function name represents the return type of the function. Some functions will return an array (@), 
some a hash (%), and others a scalar ($).  Functions that have no return value will have nothing to the left.</p>

<p>Optional parameters will be enclosed in [ ] square brackets.  The ellipse ... as a parameter indicates the function can handle 
as many arguments as you are willing to specify.</p>

<p>Parameters specified as <code>@|&</code> represent that either an @array can be passed or a &generator function.  A generator function is a closure that iterates over a sequence with the yield keyword and returns $null when no values are left to iterate over.</p>

<p>A <code>^</code> indicates a literal Class value i.e. <code>^String</code>.  This is used to indicate that a function expects
a class literal as an argument (or offers one as a return value).</p>

<p>Note, the $ is not part of the function name.  It is solely shorthand for specifying the return type of the function.</p>

<h3>Array Functions</h3>

<table class="simple2" width="90%">
 <tr>
  <th width="15"></th>
  <th width="240">Function</th>
  <th>Description</th>
 </tr>  
 <tr>
  <td>$</td>
  <td>add(@array, $scalar, [index])</td>
  <td>inserts $scalar into @array at the specified index.  if no index is specified, 0 is assumed.</td>
 </tr>
 <tr>
  <td>@</td>
  <td>addAll(@a, @b)</td>
  <td>adds all of the non-present elements of @b into @a. equivalent to the union of @a and @b</td>
 </tr>
 <tr>
  <td>@</td>
  <td>array("string 1", 2, $var3, ...)</td>
  <td>creates an array with all of the function arguments</td>
 </tr>
 <tr>
  <td>$</td>
  <td>cast(@array, 't'|^Class, ...)</td>
  <td>casts @array into an object scalar representing a native java array of type t where t can be b = byte, c = char, d =
double, f = float, h = short, i = int, l = long, o = java.lang.Object, z = boolean, * = any object type.  Optionally a
^Class literal can be specified and Sleep will create an array of that type.  Arguments ... are optional and used to
represent the dimensions of the array.</td>
 </tr>
 <tr>
  <td></td>
  <td>clear(@array)</td>
  <td>clears @array</td>
 </tr>
 <tr>
  <td>@</td>
  <td>copy(@|&)</td>
  <td>returns an array with copies of the elements of @array or &generator</td>
 </tr>
 <tr>
  <td>@</td>
  <td>filter(&amp;closure, @|&)</td>
  <td>Evaluates the specified closure against each element of @array or &generator.  Each non-null value returned by &amp;closure is collected into an array that is returned by the filter() call.</td>
 </tr>
 <tr>
  <td>@</td>
  <td>flatten(@|&amp;)</td>
  <td>returns a copy of a multidimensional(?) @array or &amp;generator flattened into a one dimensional array (only array elements are flattened)</td>
 </tr>
 <tr>
  <td>@</td>
  <td>map(&amp;closure, @|&)</td>
  <td>Evaluates the specified closure against each element of @array or &generator.  Each value returned by &amp;closure is collected into an array that is returned by the map() call.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>pop(@array)</td>
  <td>removes the last element from @array and returns it</td>
 </tr>
 <tr>
  <td>$</td>
  <td>push(@array, $scalar, ...)</td>
  <td>pushes $scalar arguments on to the top of @array</td>
 </tr>
 <tr>
  <td>@</td>
  <td>reduce(@|&, &amp;closure)</td>
  <td>I probably should have learned from python and not added this but here it is anyways.  Applies &amp;closure to first two elements of @array or &generator.  Takes the resulting value and applies it to the next element of @array or &generator, so on and so forth.  Returns one value.</td>
 </tr>
 <tr>
  <td>@</td>
  <td>remove(@array, $scalar, ...)</td>
  <td>removes each specified $scalar from @array.  if no parameters are passed the active element in the current foreach loop is removed.</td>
 </tr>
 <tr>
  <td>@</td>
  <td>removeAll(@a, @b)</td>
  <td>removes all elements of @b from @a. equivalent to the different of @a and @b</td>
 </tr>
 <tr>
  <td></td>
  <td>removeAt(@arrray, index, ...)</td>
  <td>removes the elements at the specified indices.</td>
 </tr>
 <tr>
  <td>@</td>
  <td>retainAll(@a, @b)</td>
  <td>removes all elements from @a that are not present in @b.  equivalent to the intersection of @a and @b.</td>
 </tr>
 <tr>
  <td>@</td>
  <td>reverse(@|&)</td>
  <td>returns a copy of @array or &generator in reverse order</td>
 </tr>
 <tr>
  <td>@</td>
  <td>search(@array, &amp;closure, [index])</td>
  <td>Applies &amp;closure to each element of @array (beginning with the specified index).  Returns the first non-null return value of &amp;closure.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>shift(@array)</td>
  <td>removes the first element from @array and returns it.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>size(@array)</td>
  <td>returns the size of the specified @array</td>
 </tr>
 <tr>
  <td>@</td>
  <td>sort(&closure, @array)</td>
  <td>returns a copy of @array sorted using &closure</td>
 </tr>
 <tr>
  <td>@</td>
  <td>sorta(@array)</td>
  <td>returns a copy of @array sorted alphabetically</td>
 </tr>
 <tr>
  <td>@</td>
  <td>sortd(@array)</td>
  <td>returns a copy of @array sorted numerically.  For use with an array of scalar doubles.</td>
 </tr>
 <tr>
  <td>@</td>
  <td>sortn(@array)</td>
  <td>returns a copy of @array sorted numerically.  For use with an array of scalar integers.</td>
 </tr>
 <tr>
  <td>@</td>
  <td>splice(@array, @insert, [n], [m])</td>
  <td>removes m characters at position n from @array and splices in the contents of @insert.  @insert can be null.  default value of n is 0; default value of m is the length of @insert.</td>
 </tr>
 <tr>
  <td>@</td>
  <td>subarray(@array, n, [m])</td>
  <td>extracts a subarray of range n-m from @array</td>
 </tr>
</table>

<h3>Date/Time Functions</h3>

<p>In general sleep dates are represented using a scalar long that holds the number of milliseconds since the epoch.  The epoch 
is January 1st, 1970.  Many external sources will return a numerical time value in terms of the number of <i>seconds</i> since 
the epoch.</p>

<p>The 'format' parameter is used to specify the format for parsing or returning a date string.  For more information on how to 
specify the format parameter see <a href="#15">Appendix D - Date/Time Formatting</a></p>

<p>Sleep provides the following functions for date/time manipulation:</p>

<table class="simple2" width="90%">
 <tr>
  <th width="15"></th>
  <th width="240">Function</th>
  <th>Description</th>
 </tr>  

 <tr>
  <td>$</td>
  <td>formatDate([date], 'format')</td>
  <td>returns the specified data parameter formatted as a string using the specified format.  The specified date should be a scalar long representing the number of milliseconds since the epoch.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>parseDate('format', "date string")</td>
  <td>parses the specified "date string" into a scalar long following the specified 'format' to figure out exactly how the "date string" is formatted.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>ticks()</td>
  <td>returns the number of milliseconds since the epoch</td>
 </tr>
</table>

<h3>File System Information</h3>

<p>Sleep supports the following comparison operators for querying a files information:</p>

<table class="simple2" width="90%">
 <tr>
  <th width="15"></th>
  <th width="240">Operator</th>
  <th>Description</th>
 </tr>  

 <tr>
  <td></td>
  <td>-canread "file"</td>
  <td>true if the specified file can be read</td>
 </tr>
 <tr>
  <td></td>
  <td>-canwrite "file"</td>
  <td>true if the specified file can be written to</td>
 </tr>
 <tr>
  <td></td>
  <td>-exists "file"</td>
  <td>true if the specified file exists</td>
 </tr>
 <tr>
  <td></td>
  <td>-isDir "file"</td>
  <td>true if the specified file is a directory</td>
 </tr>
 <tr>
  <td></td>
  <td>-isFile "file"</td>
  <td>true if the specified file is a file</td>
 </tr>
 <tr>
  <td></td>
  <td>-isHidden "file"</td>
  <td>true if the specified file is a hidden file</td>
 </tr>
</table>

<p>Sleep also supports the following functions for getting information about files and directories:</p>

<table class="simple2" width="90%">
 <tr>
  <th width="15"></th>
  <th width="240">Function</th>
  <th>Description</th>
 </tr>  

 <tr>
  <td></td>
  <td>createNewFile("file")</td>
  <td>creates a new file</td>
 </tr>
 <tr>
  <td></td>
  <td>deleteFile("file)</td>
  <td>deletes a file</td>
 </tr>
 <tr>
  <td>$</td>
  <td>getCurrentDirectory()</td>
  <td>returns the path for the current working directory</td>
 </tr>
 <tr>
  <td>$</td>
  <td>getFileName("/path/file")</td>
  <td>returns the filename extracted from the full path</td>
 </tr>
 <tr>
  <td>$</td>
  <td>getFileParent("/path/file")</td>
  <td>returns the files parent extracted from the full path</td>
 </tr>
 <tr>
  <td>$</td>
  <td>getFileProper("path", "file", ...)</td>
  <td>combines /path and files into an appropriate filename and path for the current platform.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>lastModified("file")</td>
  <td>returns a scalar long with the time the file was last modified</td>
 </tr>
 <tr>
  <td>@</td>
  <td>listRoots()</td>
  <td>returns all of the "root" points for the file system.  In UNIX this is just /, in Windows it would be C:/, D:/, A:/</td>
 </tr>
 <tr>
  <td>$</td>
  <td>lof("file")</td>
  <td>returns the size of the specified file</td>
 </tr>
 <tr>
  <td>@</td>
  <td>ls(["directory"])</td>
  <td>gets a list of all the files in the specified directory.  if no directory is specified, the current directory is listed.</td>
 </tr>
 <tr>
  <td></td>
  <td>mkdir("directory")</td>
  <td>creates a new directory</td>
 </tr>
 <tr>
  <td></td>
  <td>rename("old", "new")</td>
  <td>renames a file</td>
 </tr>
 <tr>
  <td></td>
  <td>setLastModified("file", n)</td>
  <td>sets the last modified time of a file</td>
 </tr>
 <tr>
  <td></td>
  <td>setReadOnly("file")</td>
  <td>sets a files mode to read only.</td>
 </tr>
</table>

<h3>Hash Functions</h3>

<table class="simple2" width="90%">
 <tr>
  <th width="15"></th>
  <th width="240">Function</th>
  <th>Description</th>
 </tr>  

 <tr>
   <td>%</td>
   <td>add(%hash, key => "value", ...)</td>
   <td>adds specified key/values to the hash.</td>
 </tr> 
 <tr>
  <td></td>
  <td>clear(%hash)</td>
  <td>clears %hash</td>
 </tr>
 <tr>
  <td>%</td>
  <td>hash("key=value",blah => "value", ...)</td>
  <td>instantiates a hash with the specified values</td>
 </tr>
 <tr>
  <td>@</td>
  <td>keys(%hash)</td>
  <td>returns a sleep string array of all the keys in %hash</td>
 </tr>
 <tr>
  <td>%</td>
  <td>ohash(blah => "value", ...)</td>
  <td>instantiates an ordered hash with the specified values.  ordered hashes mantain key insertion order.  keys can be updated without changing order.</td>
 </tr>
 <tr>
  <td>%</td>
  <td>putAll(%hash, @|&amp;, [@|&amp;])</td>
  <td>populates the hash with the specified iterators.  If only one iterator is specified then the second argument
  is assumed to be the same as the first.  The first iterator is iterated over to obtain the keys for the hash
  and the second iterator is iterated over to obtain the values.</td>
 </tr>
 <tr>
  <td></td>
  <td>remove(%hash, $value, ...)</td>
  <td>removes all specified values from %hash</td>
 </tr>
 <tr>
  <td></td>
  <td>removeAt(%hash, "key", ...)</td>
  <td>removes the specified keys from the hash.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>size(%hash)</td>
  <td>returns the number of elements in %hash</td>
 </tr>
 <tr>
  <td>@</td>
  <td>values(%hash, $key)</td>
  <td>returns a flat array of all the values in %hash</td>
 </tr>
</table>

<h3>IO Related</h3>

<table class="simple2" width="90%">
 <tr>
  <th width="15"></th>
  <th width="240">Function</th>
  <th>Description</th>
 </tr>  
 <tr>
  <td>$</td>
  <td>allocate([initial size])</td>
  <td>allocates a writeable memory buffer.  calling closef on the returned buffer turns it into a readable buffer.  calling closef on a readable buffer frees the buffer.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>available([$handle])</td>
  <td>returns the number of bytes available for reading from $handle</td>
 </tr>
 <tr>
  <td>$</td>
  <td>available($handle, "delim")</td>
  <td>reads ahead in the specified handle looking to see if the specified delimeter string is present in the read
      buffer or not.  this operation uses mark and reset (meaning it will invalidate any mark you may have set on 
      the specified handle).</td>
 </tr>
 <tr>
  <td>@</td>
  <td>bread([$handle], 'format')</td>
  <td>reads data from $handle.  Returned as a scalar array with types specified by the format string</td>
 </tr>
 <tr>
  <td></td>
  <td>bwrite([$handle], 'format', ...)</td>
  <td>writes data to $handle.  each parameter represents a piece of data as specified in format.  parameters can either be 1  
      parameter per item in the format or a single array with an element for each item described by the format.</td>
 </tr>
 <tr>
  <td></td>
  <td>closef($handle)</td>
  <td>closes the IO for $handle</td>
 </tr>
 <tr>
  <td></td>
  <td>closef(port)</td>
  <td>if a port number is specified, forces Sleep to stop listening for socket connections on 
      the specified port.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>connect("host", port, [timeout], [&amp;closure], ...)</td>
  <td>connects to the specified host:port and returns a $handle.  Check for issues connecting to a host with checkError().  If 
     &amp;closure is specified, this call will not block.  &amp;closure will be called when a connection is established.  multiple key value pairs
can be specified to set parameters of the connection: linger => (the value of SO_LINGER (how long (ms) the socket waits for a TCP reset before
actually closing.); lport => (the local port number to bind to); laddr => (the local address to bind to)</td>
 </tr>
 <tr>
  <td>$</td>
  <td>consume($handle, n, [buffer size])</td>
  <td>reads and discards up to n bytes from the specified handle.  this is useful for causing data to be read and processed without the expensive conversion process
      to sleep strings (i.e. when one wants to digest or checksum a file)</td>
 </tr>
 <tr>
  <td>$</td>
  <td>exec("command", [%env], ["directory"])</td>
  <td>executes the specified command and returns a $handle.  Check for issues executing a process with checkError().  If $null is specified for either the environment (%env) or the starting "directory" then the process will inherit the current processes settings.  The "command" string is broken apart by whitespace and each token is interpreted as a separate argument to the process.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>exec(@command, [%env], ["directory"])</td>
  <td>executes the first element of the command array and returns a $handle.  Check for issues executing a process with checkError().  If $null is specified for either the environment (%env) or the starting "directory" then the process will inherit the current processes settings.  Elements 1..n of @command are interpreted as separate arguments to the process regardless of whitespace.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>fork(&amp;closure, ...)</td>
  <td>executes the specified &amp;closure as a new thread in an isolated script environment.  the return value is a $handle
      that can be used to read/write data from/to the isolated environment.  Within the isolated environment data can be
      written to/read from the returned $handle using the $source variable.  Initial values can be passed to the isolated
      environment with $key => "value" style arguments.  There is no synchronization provided for these initial values.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>getConsole()</td>
  <td>returns the $handle for stdin/stdout.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>listen(port, [timeout], [$host], [&amp;closure], ...)</td>
  <td>listens for a connection on the specified port.  Check for listening issues with the checkError() function.  If 
      &amp;closure is specified, this call will not block.  &amp;closure will be called when a connection is established.  
      The specified scalar $host will be set to the name of the host that connects (if successful).  multiple key value pairs can be specified to
set parameters of the connection: linger => (the value of SO_LINGER (how long (ms) the socket waits for a TCP reset before actually closing.);
lport => (the local port number to bind to); laddr => (the local address to bind to); and backlog => (the number of connections to queue while
waiting for a subsequent call of listen(...) to accept a connection.)</td>
 </tr>
 <tr>
  <td></td>
  <td>mark([$handle], n)</td>
  <td>marks the current point in this IO stream.  this mark can be reset back too up until n bytes has been reached.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>openf("[>>|>]file")</td>
  <td>opens the specified file for read or write and returns a $handle. >>file = append mode, >file = overwrite mode.  Check for issues opening a file with checkError()</td>
 </tr>
 <tr>
  <td>$</td>
  <td>pack('format', ...)</td>
  <td>packs data into a sleep string.  each parameter represents a piece of data as specified in 'format'.  data can be 
specified as either 1 parameter per format item or a single array with an element for each item described by the format.</td>
 </tr>
 <tr>
  <td></td>
  <td>print([$handle], "text")</td>
  <td>prints "text" to the specified handle</td>
 </tr>
 <tr>
  <td></td>
  <td>printAll([$handle], @|&)</td>
  <td>prints entire contents of passed in @array or &generator to $handle</td>
 </tr>
 <tr>
  <td></td>
  <td>printEOF([$handle])</td>
  <td>signals EOF by shutting down output for $handle</td>
 </tr>
 <tr>
  <td></td>
  <td>println([$handle], "text")</td>
  <td>prints "text" with an appended newline character to the specified handle</td>
 </tr>
 <tr>
  <td></td>
  <td>read([$handle], &closure, [n])</td>
  <td>each time text is read from $handle, &closure will be called with the $1 = to the handle and $2 = to the text.  
specifying a n value will cause $2 to be a string of n bytes.  if n is specified sleep will try to read n bytes before 
calling the closure.  the closure will be called for the last read even if &lt; n bytes are in the buffer.</td>
 </tr>
 <tr>
  <td>@</td>
  <td>readAll([$handle])</td>
  <td>reads all of the text from the specified handle</td>
 </tr>
 <tr>
  <td>$</td>
  <td>readb([$handle], n)</td>
  <td>reads n bytes from $handle.  If 0 bytes are read <var>$null</var> will be returned.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>readc([$handle])</td>
  <td>reads a single character from the specified handle</td>
 </tr>
 <tr>
  <td>$</td>
  <td>readln([$handle])</td>
  <td>reads a single line of text from the specified handle</td>
 </tr>
 <tr>
  <td>$</td>
  <td>readObject([$handle])</td>
  <td>reads a serialized scalar back from the specified handle</td>
 </tr>
 <tr>
  <td></td>
  <td>reset([$handle])</td>
  <td>resets this IO stream back to the last mark</td>
 </tr>
 <tr>
  <td>$</td>
  <td>setEncoding($handle, "charset name")</td>
  <td>sets the character set to encode/decode written/read characters with the specified handle.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>sizeof('format')</td>
  <td>using the specified data format string, calculates an estimated size of the data.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>skip([$handle], n)</td>
  <td>tells the handle to skip the next n bytes</td>
 </tr>
 <tr>
  <td>@</td>
  <td>unpack('format', "string")</td>
  <td>unpacks data from the specified sleep string.  data is returned as a sleep array with each scalar set to a type as 
specified in the format string</td> 
 </tr>
 <tr>
  <td>$</td>
  <td>wait($handle, [timeout])</td>
  <td>waits for the callback, process, or fork associated with $handle to finish.  if $handle is a fork, the return value of the fork 
will be returned by &amp;wait.  if $handle is a process, the return value of the process will be returned by &amp;wait. If the specified timeout is reached $null will be returned.</td>
 </tr>
 <tr>
  <td></td>
  <td>writeb([$handle], "string")</td>
  <td>writes the byte data of "string" to $handle</td>
 </tr>
 <tr>
  <td>$</td>
  <td>writeObject([$handle], $scalar, ...)</td>
  <td>serializes and writes all of the scalar arguments out to the specified handle</td>
 </tr>
</table>

<p>Note: STDIN/STDOUT will be used by default for any of the IO read/write functions if a $handle is not specified.</p>

<h3>Numerical Functions</h3>

<table class="simple2" width="90%">
 <tr>
  <th width="15"></th>
  <th width="240">Function</th>
  <th>Description</th>
 </tr>  

 <tr>
  <td>$</td>
  <td>abs($scalar)</td>
  <td>returns the absolute value of $scalar</td>
 </tr>
 <tr>
  <td>$</td>
  <td>acos($scalar)</td>
  <td>returns the arc consine value of angle $scalar</td>
 </tr>
 <tr>
  <td>$</td>
  <td>asin($scalar)</td>
  <td>returns the arc sine value of angle $scalar</td>
 </tr>
 <tr>
  <td>$</td>
  <td>atan($scalar)</td>
  <td>returns the arc tangent value of angle $scalar</td>
 </tr>
 <tr>
  <td>$</td>
  <td>atan2($y, $x)</td>
  <td>returns the arc tangent value of angle $y / $x</td>
 </tr>
 <tr>
  <td>$</td>
  <td>ceil($scalar)</td>
  <td>rounds $scalar up to the next integer value.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>checksum($handle, ">algorithm")</td>
  <td>setups the specified handle so that all reads (or if > is specified in the algorithm, writes) are checksummed using the specified algorithm.  This function returns a $checksum object that can be used to obtain the final digest value.  Valid algorithms are Adler32 and CRC32</td>
 </tr>
 <tr>
  <td>$</td>
  <td>checksum($checksum)</td>
  <td>returns (as a scalar long) the checksum of the handle being checksummed with $checksum</td>
 </tr>
 <tr>
  <td>$</td>
  <td>checksum("string", "algorithm")</td>
  <td>returns (as a scalar long) the checksum of the specified byte string using the specified algorithm</td>
 </tr>
 <tr>
  <td>$</td>
  <td>cos($scalar)</td>
  <td>returns the cosine value of angle $scalar (radians)</td>
 </tr>
 <tr>
  <td>$</td>
  <td>degrees($scalar)</td>
  <td>converts the angle $scalar measured in radians to an approximately equivalent angle in degrees</td>
 </tr>
 <tr>
  <td>$</td>
  <td>digest($handle, ">algorithm")</td>
  <td>setups the specified handle so that all reads (or if > is specified in the algorithm, writes) are digested using the specified algorithm.  This function returns a $digest object that can be used to obtain the final digest value.  Valid algorithms are MD5 and SHA-1</td>
 </tr>
 <tr>
  <td>$</td>
  <td>digest($digest)</td>
  <td>returns (as bytes) the digest of the handle being digested with $digest</td>
 </tr>
 <tr>
  <td>$</td>
  <td>digest("string", "algorithm")</td>
  <td>returns (as bytes) the digest of the specified byte string using the specified algorithm</td>
 </tr>
 <tr>
  <td>$</td>
  <td>double($scalar)</td>
  <td>returns a copy of $scalar as a double scalar</td>
 </tr>
 <tr>
  <td>$</td>
  <td>exp($scalar)</td>
  <td>returns Euler's number raised to the $scalar power</td>
 </tr>
 <tr>
  <td>$</td>
  <td>floor($scalar)</td>
  <td>rounds $scalar down to the closest integer value.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>formatNumber(number, [from], to)</td>
  <td>formats specified number from specified base to specified base.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>int($scalar)</td>
  <td>returns a copy of $scalar as an integer scalar</td>
 </tr>
 <tr>
  <td>$</td>
  <td>log($scalar, [base])</td>
  <td>returns the logarithm of $scalar.  If no base is specified, returns the natural logarithm of $scalar.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>long($scalar)</td>
  <td>returns a copy of $scalar as a long scalar</td>
 </tr>
 <tr>
  <td>$</td>
  <td>not($scalar)</td>
  <td>returns the logical not of $scalar</td>
 </tr>
 <tr>
  <td>$</td>
  <td>parseNumber(number, [base])</td>
  <td>parses number of specified base value (base as in binary (2), decimal (10), hex (16) etc.)</td>
 </tr>
 <tr>
  <td>$</td>
  <td>radians($scalar)</td>
  <td>converts the angle $scalar measured in degrees to an approximately equivalent angle in radians</td>
 </tr>
 <tr>
  <td>$</td>
  <td>rand([number])</td>
  <td>generates a random integer between 0 and number.  If number is ommited the function generates a random double between 0 and 1</td>
 </tr>
 <tr>
  <td>$</td>
  <td>rand(@array)</td>
  <td>returns a random element of @array</td>
 </tr>
 <tr>
  <td>$</td>
  <td>round($scalar)</td>
  <td>rounds $scalar to the nearest whole number</td>
 </tr>
 <tr>
  <td>$</td>
  <td>sin($scalar)</td>
  <td>returns the sine value of angle $scalar (radians)</td>
 </tr>
 <tr>
  <td>$</td>
  <td>sqrt($scalar)</td>
  <td>returns the rounded positive square root of $scalar</td>
 </tr>
 <tr>
   <td>$</td>
   <td>srand($scalar)</td>
   <td>seeds the random number generator with the specified scalar (interpreted as a long)</td>
 </tr>
 <tr>
  <td>$</td>
  <td>tan($scalar)</td>
  <td>returns the tangent value of angle $scalar (radians)</td>
 </tr>
 <tr>
  <td>$</td>
  <td>uint($scalar)</td>
  <td>returns a scalar long based on $scalar interpreted as an unsigned integer</td>
 </tr>
</table>

<p>The numerical constants PI and E are available as <code>[Math PI]</code> and <code>[Math E]</code> respectively.</p>

<h3>String Functions</h3>

<table class="simple2" width="90%">
 <tr>
  <th width="15"></th>
  <th width="240">Function</th>
  <th>Description</th>
 </tr>  

 <tr>
  <td>$</td>
  <td>asc("x")</td>
  <td>returns a scalar integer of the ascii value of the specified character</td>
 </tr>
 <tr>
  <td>$</td>
  <td>byteAt("string", n)</td>
  <td>returns the byte (really its an intger) at the n'th position in the string</td>
 </tr>
 <tr>
  <td>$</td>
  <td>cast("string", 't')</td>
  <td>casts "string" into an object scalar representing a native java array of type t where t can be b = byte, c = char.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>chr(number)</td>
  <td>returns the ascii character associated with the specified ascii value</td>
 </tr>
 <tr>
  <td>$</td>
  <td>charAt("string", n)</td>
  <td>returns the character at the n'th position in the string</td>
 </tr>
 <tr>
  <td>$</td>
  <td>indexOf("string", "substr", [start])</td>
  <td>returns the index of "substr" inside of "string" starting at the specified start index.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>lindexOf("string", "substr", [start])</td>
  <td>returns the last index of "substr" inside of "string" looking backwards from the specified start index.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>join("string", @|&amp;)</td>
  <td>joins the elements of @array or &amp;generator with "string"</td>
 </tr>
 <tr>
  <td>$</td>
  <td>lc("STRING")</td>
  <td>returns a lowercase version of the specified string</td>
 </tr>
 <tr>
  <td>$</td>
  <td>left("string", n)</td>
  <td>returns the left n characters of "string"</td>
 </tr>
 <tr>
  <td>@</td>
  <td>matched()</td>
  <td>returns the matches from a "string" applied to a regex 'pattern' during an ismatch/hasmatch comparison</td>
 </tr>
 <tr>
  <td>@</td>
  <td>matches("string", 'pattern', [n], [m])</td>
  <td>returns the matches from "string" applied to the regex 'pattern'.  if n is specified this will return the grouped 
matches of the n'th substring matching the specified pattern.  if n and m are specified, all of the grouped matches of the 
n-m substrings will be returned.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>mid("string", start, n)</td>
  <td>returns a substring of the specified "string" starting from the start index followed by the next n chars</td>
 </tr>
 <tr>
  <td>$</td>
  <td>replace("string", 'pattern', "new", [n])</td>
  <td>splits "string" by regex 'pattern' in "string" and joins it with specified "new" value.  will replace up to n occurences. 
  within the "new" string remembered patterns can be expanded with the literal $1, $2, etc.  These are literal characters  
  provided by the regex engine.  </td>
 </tr>
 <tr>
  <td>$</td>
  <td>replaceAt("string", "new", index, [n])</td>
  <td>removes n characters from the specified index (or just len of the new string if n isn't
      specified) then inserts the new string into the specified index.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>right("string", n)</td>
  <td>returns the right most n characters of "string'</td>
 </tr>
 <tr>
  <td>@</td>
  <td>split('pattern', "string")</td>
  <td>splits the specified string by the specified pattern</td>
 </tr>
 <tr>
  <td>$</td>
  <td>strlen("string")</td>
  <td>returns the length of the specified string</td>
 </tr>
 <tr>
  <td>$</td>
  <td>strrep("string", "old", "new", ...)</td>
  <td>replaces occurrences of old with new in string. accepts multiple old, new parameters.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>substr("string", start, end)</td>
  <td>returns a substring of the specified "string"</td>
 </tr>
 <tr>
  <td>$</td>
  <td>tr("string", "old", "new", ['options'])</td>
  <td>applies translation old/new against specified string. See <a href="#17">Appendix F</a> for more info.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>uc("string")</td>
  <td>returns an uppercase version of "string"</td>
 </tr>
</table>

<h3>Utility Functions</h3>

<table class="simple2" width="90%">
 <tr>
  <th width="15"></th>
  <th width="240">Function</th>
  <th>Description</th>
 </tr>  
 <tr>
  <td></td>
  <td>acquire($semaphore)</td>
  <td>blocks the current thread of execution until the semaphore count is > 0, when that happens the semaphore count is decremented.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>checkError([$scalar])</td>
  <td>returns the last error message to occur.  if a $scalar is specified : $scalar is set to the error string.  Once chekError() is called the error message is cleared.  Functions that might flag an error will be documented.  Any type of Scalar can be returned by checkError(). i.e. often times the error message might be a Java exception Object.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>compile_closure("code", ...)</td>
  <td>compiles the specified code into a sleep closure.  key/value pairs can be specified as initial values similar to &amp;lambda.  syntax errors can be obtained with &amp;checkError()</td>
 </tr>
 <tr>
  <td>$</td>
  <td>casti($scalar, 't'|^Class)</td>
  <td>casts $scalar into an object scalar representing a native java value of type t where t can be b = byte, c = char, d = 
      double, f = float, h = short, i = int, l = long, o = java.lang.Object, z = boolean.  Optionally a ^Class literal can be
      specified in place of a type string.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>debug(level)</td>
  <td>explicitly enables the specified debug level for this script: 0 - no debugging; 1 - show only critical
errors (default); 2 - show all messages flagged for retrieval with checkError(); 4 - show first time use of
non-declared variables; 8 - trace all function calls (collects profiler statistics); 24 - trace only for the
purpose of collecting profiler statistics; 34 - "throw" all messages flagged for use with checkError() - this
allows use of try/catch to deal with errors; 64 - trace all logical comparisons.  any of the levels can be |'d 
together.</td>
 </tr>
 <tr>
  <td>$</td>
  <td width="240">eval("code")</td>
  <td>parses and evaluates the specified code returning the return value of the code.  syntax errors can be obtained with &amp;checkError()</td>
 </tr>
 <tr>
  <td>$</td>
  <td>exit(["reason"])</td>
  <td>causes the currently executing script context to exit.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>expr("expr")</td>
  <td>parses and evaluates the specified sleep expression code returning the value of the expression.  syntax errors can be obtained with &amp;checkError()</td>
 </tr>
 <tr>
  <td>$</td>
  <td>function('&func_name')</td>
  <td>obtains the function handle for the function bound to the specified string</td>
 </tr>
 <tr>
  <td>@</td>
  <td>getStackTrace()</td>
  <td>in the context of a catch block (try/catch handlers) this function will return a trace of the Sleep call stack
      that caused the exceptional condition.  Returns an empty array otherwise.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>global('$x $y')</td>
  <td>parses the specified string and declares all variables in the string as global variables.</td>
 </tr>
 <tr>
  <td></td>
  <td>include("/path/to/file.sl")</td>
  <td>compiles and executes the specified script file in the current script context.</td>
 </tr>
 <tr>
  <td></td>
  <td>include(["/file.jar"], "/path/to/script.sl")</td>
  <td>compiles and executes the specified script file in the current script context.  this form of the include function looks for script.sl inside of file.jar.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>invoke(&amp;closure, @args, ["message"], ...)</td>
  <td>invokes the specified closure using the specified array for each individual argument.  the message parameter ($0) can be specified as well.  Optional named parameters include <i>message</i>, <i>$this</i> which specifies the closure scope to execute with, and <i>parameter</i> which is a hash of all key/value pairs to pass to the function.</td>
 </tr>
 <tr> 
  <td>&amp;</td>
  <td>lambda(&amp;closure,&nbsp;$key&nbsp;=&gt;&nbsp;"value",&nbsp;...)</td>
  <td>copies &amp;closure into a new closure.  The closure environment is initialized with all of the key/value pair arguments.  If <var>$this</var> => &amp;closure is specified then the resulting closure will share a <var>$this</var> scope with the specified &amp;closure.</td>
 </tr>
 <tr> 
  <td>&amp;</td>
  <td>let(&amp;closure,&nbsp;$key&nbsp;=&gt;&nbsp;"value",&nbsp;...)</td>
  <td>The specified closure's environment is updated with all of the key/value pair arguments.  Returns the specified closure.</td>
 </tr>
 <tr>
  <td></td>
  <td>local('$x $y')</td>
  <td>parses the specified string and declares all variables in the string as local variables.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>newInstance(@|^Interface, &closure)</td>
  <td>Creates a sleep closure backed instance of the specified java interface class (or classes if an array is used).</td>
 </tr>
 <tr>
  <td>@</td>
  <td>profile()</td>
  <td>returns the profiler statistics for the current script environment.  Profile statistics will only be collected if DEBUG_TRACE_CALLS (8) or DEBUG_TRACE_PROFILE_ONLY (24) is set.</td>
 </tr>
 <tr>
  <td></td>
  <td>release($semaphore)</td>
  <td>increments the count value of the specified semaphore.</td>
 </tr>
 <tr>
  <td></td>
  <td>setf('&func_name', &closure)</td>
  <td>sets the specified function to be bound to the specified closure.</td>
 </tr>
 <tr>
  <td></td>
  <td>setField(^class|$object, field => value, ...)</td>
  <td>sets any number of public/protected fields of the specified class or instance of $object to a corresponding value.</td>
 </tr>
 <tr>
  <td>$</td>
  <td>semaphore([initial value])</td>
  <td>constructs a $semaphore suitable for use with &amp;acquire and &amp;release.</td>
 </tr>
 <tr>
  <td></td>
  <td>sleep(n)</td>
  <td>force the current executing thread to sleep for n milliseconds</td>
 </tr>
 <tr>
  <td>%</td>
  <td>systemProperties()</td>
  <td>returns a hash of the available system properties.   See <a href="#12">Appendix A</a> for a list of some of the system properties</td>
 </tr>
 <tr>
  <td></td>
  <td>this('$x $y')</td>
  <td>parses the specified string and declares all variables in the string as variables specific to the current closure.</td>
 </tr>
 <tr>   
  <td>$</td>
  <td>typeOf($scalar)</td>
  <td>returns the Java ^Class backing the specified scalar.</td>
 </tr>
 <tr>
  <td></td>
  <td>use("Loadable"|^Loadable)</td>
  <td>loads the specified class into the current script environment.  Classes specified as package.Name are loaded from the Java classpath.  Classes can also be specified as filenames without the .class extension.  The specified class must be a Loadable bridge (i.e. it implements sleep.interfaces.Loadable).  Optionally a class literal can be specified as an argument and Sleep will instantiate an instance of that class and install it as a bridge into the current script environment.  This is a safer way to use this function as the class name can be checked at script compile time.</td>
 </tr>
 <tr>
  <td></td>
  <td>use("/path/to/file.jar", "Loadable")</td>
  <td>loads the specified class into the current script environment.  The sleep.interfaces.Loadable class is loaded from the specified jar file.  Use to import sleep modules and the like.</td>
 </tr>
 <tr>
  <td></td>
  <td>watch('$x $y')</td>
  <td>A useful debug function for tracking variable changes.  parses the specified string and declares all variables in the string as "watch" variables.  Any attempt to update the container *referenced* by a watch variable will print out a warning.</td>
 </tr>
</table>

<h2><a name="12">Appendix A - System Properties</a></h2>

<p>This appendix contains a list of system properties available in the hash returned by the systemProperties() function.  This 
list is not comprehensive:</p>

<table class="simple2" width="90%">
 <tr>
  <th width="255">Key</th>
  <th>Example Value</th>
 </tr>  
 <tr>
  <td>java.io.tmpdir</td>
  <td>/tmp</td>
 </tr>
 <tr>
  <td>java.runtime.name</td>
  <td>Java(TM) 2 Runtime Environment, Standard Edition</td>
 </tr>
 <tr>
  <td>java.vm.version</td>
  <td>1.4.1_01-24</td>
 </tr>
 <tr>
  <td>path.separator</td>
  <td>:         <i>the file path separator for the current platform</i></td>
 </tr>
 <tr>
  <td>os.arch</td>
  <td>ppc</td>
 </tr>
 <tr>
  <td>os.name</td>
  <td>Mac OS X</td>
 </tr>
 <tr>
  <td>os.version</td>
  <td>10.2.8</td>
 </tr>
 <tr>
  <td>user.country</td>
  <td>US</td>
 </tr>
 <tr>
  <td>user.dir</td>
  <td>/home/raffi/sleep/bin     <i>the current active directory</i></td>
 </tr>
 <tr>
  <td>user.home</td>
  <td>/home/raffi</td>
 </tr>
 <tr>
  <td>user.timezone</td>
  <td>EST</td>
 </tr>
</table>

<h2><a name="13">Appendix B - Wildcard Strings</a></h2>

<p>Sleep has the ability to determine if a string matches a specified wildcard string.  This appendix is just a quick 
refresher.</p>

<p>A wildcard string can be a normal string.  For example you can check if the wildcard string "Jack" matches "John".  The result 
will be false.  This is because Jack does not match John.  They are not the same thing.</p>

<p>Wildcard strings have four special sequences *, **, ?, and \.</P>

<p>The ? question mark character allows for any one character to be in that position.  For example the wildcard string "J?ck" 
matches the string "Jack".  "J?ck" will also matche "Jick", "Jock", and "Jeck".  Where the ? question mark is any thing can go.  
Something must go there though.  For example "J?ck" is not a wildcard match for "Jck".</p>

<p>The * asterisk special character allows for zero or more characters to be in that position.  For example the wildcard 
string "J?c*" matches "Jack".  The wildcard string also matches "Jock Strap", "Jeck is not a word", and other fun phrases.  
When matching is done with * it is done in a non-greedy fashion.  This means as soon as the the matcher encounters a 
sequence that allows it to continue to the next part of the wildcard string it will.</p>

<pre>if ("*@aol.com" iswm $email)
{
   # address belongs to an AOL wARRIOR
}</pre>

<p>The above code snippet checks if the wildcard string *@aol.com is a a match for $email.  If it is then we know that the email 
address is an AOL email address.</p>

<p>The ** asterisk sequence also allows for zero or more characters to be in that position.  The only difference is matching is 
handled in a greedy fashion.  This means the matcher will try to consume as many characters as possible before continuing to 
the next part of the wildcard string.</p>

<p>The '\' backslash character is used to escape a character.  If you want to specify a literal question mark '?' or asterisk 
'*' in your pattern prefix it with a '\' backslash.</p>

<h3>Greedy versus Non-Greedy</h3>

<pre>if ('this*test' iswm 'this is me testing with this test')
{
   # Non-greedy example: no match
}</pre>

<pre>if ('this**test' iswm 'this is me testing with this test')
{
   # Greedy example: we have a match
}</pre>

<p>The two examples above illustrate greedy versus non-greedy matching.  In the non-greedy example the matcher will find "this" 
and then it will use the * for "is me" before encountering the next part of the pattern which is "test" in the string "testing 
with this test".</p>

<p>In the greedy example the matcher will find "this" and it will then use * for as much stuff as possible.  Taking it all the 
way to the end of the string where "test" is.</p>

<h2><a name="14">Appendix C - Regular Expression Pattern Syntax</a></h2>

<p>Think of a pattern as a description of a string.  A pattern describes what an "acceptable" string looks like.   When a string 
is applied to a pattern, the regex engine goes through the string character by character advancing it through the pattern.  If 
the entire string makes it through the entire pattern it matches.  If it doesn't then the string does not match the pattern i.e. 
it is not an "acceptable" string.</p>

<p>Regular expression patterns are composed of pattern elements.  A pattern element is just a way of specifying what part of a 
string should look like.  This appendix describes the literal character and character group pattern elements.  It also describes 
how to group pattern elements and how to attach quantifiers to the pattern elements.</p>

<p>This appendix is only meant to serve as an introduction to the topic.  It is by no means a complete reference.</p>

<h3>Literal Characters</h3>

<p>Literal characters match exactly.  For example letters (a-z, A-Z), digits (0-9), and some special characters (%, @) all mean 
themselves.  When the regex engine encounters a literal character it is looking for the next character in the applied string to 
be the literal character.</p>

<p>To make special characters into literal characters escape them using a \ backslash.  For example ? question mark has a special 
meaning.  You can escape it with \?.</p>

<h3>Character Groups</h3>

<p>Character groups are a way of grouping characters together.  When the regex engine encounters a character group it is looking 
to see if the next character in the applied string matches anything specified in the character group.  Character groups are 
enclosed in [ ] square brackets.</p>

<pre>if ("i" ismatch '[aeiou]') { }</pre>

<p>In the above example we are looking to see if y matches the pattern of vowels.  The character group within the pattern will 
accept 'a' or 'e' or 'i' or 'o' or 'u'.  Nothing else will be accepted for that first and only letter.</p>

<p>It is also possible to negate a character group by making the first character a ^ hat symbol.</p>

<pre>if ("y" ismatch '[^aeiou]') { }</pre>

<p>In the above example any consonant will match.  Any vowels will be rejected because the ^ hat in the beginning of the 
character says 'do not accept any of these characters'.  The value "y" will be accepted as a match since y is not a, e, i, o, or 
u.</p>

<p>Within the square brackets it is also possible to specify a range of characters.</p>

<pre>if ("C" ismatch '[a-zA-Z]') { }</pre>

<p>In the above example we are looking to match any character a through z or A through Z.  You could just as easily write 
'[a-cD-Z]' which would match any character a through c or D through Z.  The value "C" is a match since "C" is in one of the 
ranges a-z or A-Z.</p>

<p>The regex engine also includes quick shortcuts for writing common character groups. The escape "\d" matches any digit.  Using 
"\d" is equivalent to using "[0-9]".  "\w" will match any word character a-z, A-Z, and _ underscore.  "\s" will match any white 
space character such as tabs, spaces, and new lines.  Uppercase versions of these shortcuts are the same as using ^ hat.  "\W" 
will match any character that is not a word character.</p>

<p>The meta character . period is a character class that will match any character.</p>

<h3>Pattern Grouping</h3>

<p>Pattern elements enclosed in ( ) parentheses are considered to be grouped together.  This grouping makes the regex engine 
consider the elements in the group to be one element.  This way count quantifiers can be applied to the group as a whole.</P>

<p>Enclosing pattern elements in ( ) parentheses also  has the effect of making the regex engine "remember" the text in the 
applied string that matched the enclosed pattern.  The matched text can be retrieved with the sleep function matches().</p>

<pre>if ('You ZEBRA' ismatch '(Y[aeiou][aeiou])\sZEBRA') { }</pre>

<p>In the above example three pattern elements are grouped together.  The literal character Y followed by our character group for 
vowels.  The grouping now makes the regex engine consider these three pattern elements to be one pattern element.  It doesn't 
make much of a difference to the matching unless a quantifier is attached to the grouped pattern elements (see below).  The 
regex engine will remember the applied string text that matched the pattern elements enclosed in the ( ) parentheses.</p>

<pre>@data = matches("You ZEBRA", '(Y[aeiou][aeiou])\sZEBRA');</pre>

<p>In the example above the array @data would contain one element, the string "You".</p>

<h3>Count Quantifiers</h3>

<p>Count quantifiers affect the previous element.  Whether this element is a literal character, a character group, or a pattern 
grouping.  Count quantifiers are a way of specifying how many times you want to see the previous element occur at this point in 
the pattern.</p>

<p>The count quantifier + means match the previous element 1 or more times.</p>

<pre>if ('uaiaaeeueeiiioiauZEBRA' ismatch '[aeiou]+ZEBRA') { }</pre>

<p>In the above example the pattern is looking for the character class of 'a' or 'e' or 'i' or 'u' to match 1 or more times.  So 
the first character in the applied string can be a, e, i, o, or u. The second character of the applied string can be a, e, i, o, 
or u.  The regex engine keeps looking through the applied string until the current character no longer matches the character 
class.  The regex engine then tries to apply the next part of the pattern.  Which in this case is the literal characters 
ZEBRA.</p>

<p>The count quanitifer * asterisk means match the previous element 0 or more times.  The count quantifier ? question mark means 
look for the previous element to occur once or not a all.</p>

<p>You can also specify your own count quantifier using { } curly braces.  You can use {5} to mean match the previous element 5 
times exactly.  Or you can specify a range {4, 10} meaning match the previous element 4 to 10 times.</p>

<p>Attaching the ? question mark onto any count quantifier results in the regular expression being processed in a reluctant 
manner rather than a greedy manner.  Reluctant means the regex engine will look to see if it can move ahead to the next part of 
the pattern.  Greedy means the regex engine will always try to stay at the current part of the pattern when processing a 
string.</p>

<h3>The OR Quantifier</h3>

<p>Another quantifier worth writing about is the OR quantifier. The OR quantifier is represented with a | pipe symbol. The OR 
quantifier uses the previous and next elements.  It says the next character can match the pattern element before the | pipe 
symbol or the next character can match the pattern element after the | pipe symbol.</p>

<pre>if ('uaiaaeeueeiiioiauZEBRA' ismatch '[aeiou]+|XZEBRA') { }
if ('XZEBRA' ismatch '[aeiou]+|XZEBRA') { }</pre>

<p>In the above example we have modified our 'look for a string of vowels 1 or more characters long followed by the word ZEBRA' 
pattern.  We have attached the | quantifier after the character group followed by a count quantifier.  Remember the character 
group with attached count quantifier is now thought of as one single element.  The | quantifier says this part of an acceptable 
string can be either the previous element ([aeiou]+) OR it can be the next element (the literal character X).   It can't be both 
it can only be one or the other.</p>

<h3>Regex Options</h3>

<p>It is possible to set/unset a few switches for your patterns.  You can use (?options) to enable or (?-options) to disable 
certain options each specified with a single character.  The <var>i</var> option when set makes the pattern matching case 
insensitive.  The <i>d</i> option when set enables UNIX lines mode.  The <var>m</var> enables Multiline mode which makes the ^ 
(beginning of input character) and $ (end of input character) match at the beginning/end of each line.  The <var>s</var> flag 
makes the . character match any character including line feeds.  Finally, the <var>x</var> makes the matcher ignore white space 
in the pattern and enables pattern comments (beginning with a #, ending with a newline).</p>

<h3>Summary of Regex Constructs</h3>

<p>Sleeps regex functions are backed by Java's regex engine.  The following table was derived from the Javadoc API
for <code><a href="http://java.sun.com/j2se/1.4.1/docs/api/java/util/regex/Pattern.html">java.util.regex.Pattern</a></code>.</p>

<table border="0" cellpadding="1" cellspacing="0" class="simple2">

 <tr align="left">
 <th align="left" id="construct">Construct</th>
 <th align="left" id="matches">Matches</th>
 </tr>

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="characters"><b>Characters</b></td></tr>

 <tr><td valign="top" headers="construct characters"><i>x</i></td>
     <td headers="matches">The character <i>x</i></td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\\</tt></td>
     <td headers="matches">The backslash character</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>n</i></td>
     <td headers="matches">The character with octal value <tt>0</tt><i>n</i>
         (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>nn</i></td>
     <td headers="matches">The character with octal value <tt>0</tt><i>nn</i>
         (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\0</tt><i>mnn</i></td>
     <td headers="matches">The character with octal value <tt>0</tt><i>mnn</i>
         (0&nbsp;<tt>&lt;=</tt>&nbsp;<i>m</i>&nbsp;<tt>&lt;=</tt>&nbsp;3,
         0&nbsp;<tt>&lt;=</tt>&nbsp;<i>n</i>&nbsp;<tt>&lt;=</tt>&nbsp;7)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\x</tt><i>hh</i></td>
     <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hh</i></td></tr>
 <tr><td valign="top" headers="construct characters"><tt>&#92;u</tt><i>hhhh</i></td>
     <td headers="matches">The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><i>hhhh</i></td></tr>
 <tr><td valign="top" headers="matches"><tt>\t</tt></td>
     <td headers="matches">The tab character (<tt>'&#92;u0009'</tt>)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\n</tt></td>
     <td headers="matches">The newline (line feed) character (<tt>'&#92;u000A'</tt>)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\r</tt></td>
     <td headers="matches">The carriage-return character (<tt>'&#92;u000D'</tt>)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\f</tt></td>
     <td headers="matches">The form-feed character (<tt>'&#92;u000C'</tt>)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\a</tt></td>
     <td headers="matches">The alert (bell) character (<tt>'&#92;u0007'</tt>)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\e</tt></td>
     <td headers="matches">The escape character (<tt>'&#92;u001B'</tt>)</td></tr>
 <tr><td valign="top" headers="construct characters"><tt>\c</tt><i>x</i></td>
     <td headers="matches">The control character corresponding to <i>x</i></td></tr>

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="classes"><b>Character classes</b></td></tr>

 <tr><td valign="top" headers="construct classes"><tt>[abc]</tt></td>
     <td headers="matches"><tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (simple class)</td></tr>
 <tr><td valign="top" headers="construct classes"><tt>[^abc]</tt></td>
     <td headers="matches">Any character except <tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (negation)</td></tr>
 <tr><td valign="top" headers="construct classes"><tt>[a-zA-Z]</tt></td>
     <td headers="matches"><tt>a</tt> through <tt>z</tt>
         or <tt>A</tt> through <tt>Z</tt>, inclusive (range)</td></tr>
 <tr><td valign="top" headers="construct classes"><tt>[a-d[m-p]]</tt></td>
     <td headers="matches"><tt>a</tt> through <tt>d</tt>,
      or <tt>m</tt> through <tt>p</tt>: <tt>[a-dm-p]</tt> (union)</td></tr>
 <tr><td valign="top" headers="construct classes"><tt>[a-z&&[def]]</tt></td>
     <td headers="matches"><tt>d</tt>, <tt>e</tt>, or <tt>f</tt> (intersection)</tr>
 <tr><td valign="top" headers="construct classes"><tt>[a-z&&[^bc]]</tt></td>
     <td headers="matches"><tt>a</tt> through <tt>z</tt>,
         except for <tt>b</tt> and <tt>c</tt>: <tt>[ad-z]</tt> (subtraction)</td></tr>
 <tr><td valign="top" headers="construct classes"><tt>[a-z&&[^m-p]]</tt></td>
     <td headers="matches"><tt>a</tt> through <tt>z</tt>,
          and not <tt>m</tt> through <tt>p</tt>: <tt>[a-lq-z]</tt>(subtraction)</td></tr>

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="predef"><b>Predefined character classes</b></td></tr>

 <tr><td valign="top" headers="construct predef"><tt>.</tt></td>
     <td headers="matches">Any character (may or may not match line terminators)</td></tr>
 <tr><td valign="top" headers="construct predef"><tt>\d</tt></td>
     <td headers="matches">A digit: <tt>[0-9]</tt></td></tr>
 <tr><td valign="top" headers="construct predef"><tt>\D</tt></td>
     <td headers="matches">A non-digit: <tt>[^0-9]</tt></td></tr>
 <tr><td valign="top" headers="construct predef"><tt>\s</tt></td>
     <td headers="matches">A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
 <tr><td valign="top" headers="construct predef"><tt>\S</tt></td>
     <td headers="matches">A non-whitespace character: <tt>[^\s]</tt></td></tr>
 <tr><td valign="top" headers="construct predef"><tt>\w</tt></td>
     <td headers="matches">A word character: <tt>[a-zA-Z_0-9]</tt></td></tr>
 <tr><td valign="top" headers="construct predef"><tt>\W</tt></td>
     <td headers="matches">A non-word character: <tt>[^\w]</tt></td></tr>

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="posix"><b>POSIX character classes</b> (US-ASCII only)</td></tr>

 <tr><td valign="top" headers="construct posix"><tt>\p{Lower}</tt></td>
     <td headers="matches">A lower-case alphabetic character: <tt>[a-z]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Upper}</tt></td>
     <td headers="matches">An upper-case alphabetic character:<tt>[A-Z]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{ASCII}</tt></td>
     <td headers="matches">All ASCII:<tt>[\x00-\x7F]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Alpha}</tt></td>
     <td headers="matches">An alphabetic character:<tt>[\p{Lower}\p{Upper}]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Digit}</tt></td>
     <td headers="matches">A decimal digit: <tt>[0-9]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Alnum}</tt></td>
     <td headers="matches">An alphanumeric character:<tt>[\p{Alpha}\p{Digit}]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Punct}</tt></td>
     <td headers="matches">Punctuation: One of <tt>!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~</tt></td></tr>
     <!-- <tt>[\!"#\$%&'\(\)\*\+,\-\./:;\<=\>\?@\[\\\]\^_`\{\|\}~]</tt>
          <tt>[\X21-\X2F\X31-\X40\X5B-\X60\X7B-\X7E]</tt> -->
 <tr><td valign="top" headers="construct posix"><tt>\p{Graph}</tt></td>
     <td headers="matches">A visible character: <tt>[\p{Alnum}\p{Punct}]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Print}</tt></td>
     <td headers="matches">A printable character: <tt>[\p{Graph}]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Blank}</tt></td>
     <td headers="matches">A space or a tab: <tt>[ \t]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Cntrl}</tt></td>
     <td headers="matches">A control character: <tt>[\x00-\x1F\x7F]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{XDigit}</tt></td>
     <td headers="matches">A hexadecimal digit: <tt>[0-9a-fA-F]</tt></td></tr>
 <tr><td valign="top" headers="construct posix"><tt>\p{Space}</tt></td>
     <td headers="matches">A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="unicode"><b>Classes for Unicode blocks and categories</b></td></tr>

 <tr><td valign="top" headers="construct unicode"><tt>\p{InGreek}</tt></td>
     <td headers="matches">A character in the Greek&nbsp;block (simple block)</td></tr>
 <tr><td valign="top" headers="construct unicode"><tt>\p{Lu}</tt></td>
     <td headers="matches">An uppercase letter (simple category)</td></tr>
 <tr><td valign="top" headers="construct unicode"><tt>\p{Sc}</tt></td>
     <td headers="matches">A currency symbol</td></tr>
 <tr><td valign="top" headers="construct unicode"><tt>\P{InGreek}</tt></td>
     <td headers="matches">Any character except one in the Greek block (negation)</td></tr>
 <tr><td valign="top" headers="construct unicode"><tt>[\p{L}&&[^\p{Lu}]]&nbsp;</tt></td>
     <td headers="matches">Any letter except an uppercase letter (subtraction)</td></tr>

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="bounds"><b>Boundary matchers</b></td></tr>

 <tr><td valign="top" headers="construct bounds"><tt>^</tt></td>
     <td headers="matches">The beginning of a line</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>$</tt></td>
     <td headers="matches">The end of a line</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>\b</tt></td>
     <td headers="matches">A word boundary</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>\B</tt></td>
     <td headers="matches">A non-word boundary</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>\A</tt></td>
     <td headers="matches">The beginning of the input</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>\G</tt></td>
     <td headers="matches">The end of the previous match</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>\Z</tt></td>
     <td headers="matches">The end of the input but for the final
          terminator, if&nbsp;any</td></tr>
 <tr><td valign="top" headers="construct bounds"><tt>\z</tt></td>
     <td headers="matches">The end of the input</td></tr>

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="greedy"><b>Greedy quantifiers</b></td></tr>

 <tr><td valign="top" headers="construct greedy"><i>X</i><tt>?</tt></td>
     <td headers="matches"><i>X</i>, once or not at all</td></tr>
 <tr><td valign="top" headers="construct greedy"><i>X</i><tt>*</tt></td>
     <td headers="matches"><i>X</i>, zero or more times</td></tr>
 <tr><td valign="top" headers="construct greedy"><i>X</i><tt>+</tt></td>
     <td headers="matches"><i>X</i>, one or more times</td></tr>
 <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>}</tt></td>
     <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
 <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,}</tt></td>
     <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
 <tr><td valign="top" headers="construct greedy"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}</tt></td>
     <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="reluc"><b>Reluctant quantifiers</b></td></tr>

 <tr><td valign="top" headers="construct reluc"><i>X</i><tt>??</tt></td>
     <td headers="matches"><i>X</i>, once or not at all</td></tr>
 <tr><td valign="top" headers="construct reluc"><i>X</i><tt>*?</tt></td>
     <td headers="matches"><i>X</i>, zero or more times</td></tr>
 <tr><td valign="top" headers="construct reluc"><i>X</i><tt>+?</tt></td>
     <td headers="matches"><i>X</i>, one or more times</td></tr>
 <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>}?</tt></td>
     <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
 <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,}?</tt></td>
     <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
 <tr><td valign="top" headers="construct reluc"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}?</tt></td>
     <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="poss"><b>Possessive quantifiers</b></td></tr>

 <tr><td valign="top" headers="construct poss"><i>X</i><tt>?+</tt></td>
     <td headers="matches"><i>X</i>, once or not at all</td></tr>
 <tr><td valign="top" headers="construct poss"><i>X</i><tt>*+</tt></td>
     <td headers="matches"><i>X</i>, zero or more times</td></tr>
 <tr><td valign="top" headers="construct poss"><i>X</i><tt>++</tt></td>
     <td headers="matches"><i>X</i>, one or more times</td></tr>
 <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>}+</tt></td>
     <td headers="matches"><i>X</i>, exactly <i>n</i> times</td></tr>
 <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,}+</tt></td>
     <td headers="matches"><i>X</i>, at least <i>n</i> times</td></tr>
 <tr><td valign="top" headers="construct poss"><i>X</i><tt>{</tt><i>n</i><tt>,</tt><i>m</i><tt>}+</tt></td>
     <td headers="matches"><i>X</i>, at least <i>n</i> but not more than <i>m</i> times</td></tr>

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="logical"><b>Logical operators</b></td></tr>

 <tr><td valign="top" headers="construct logical"><i>XY</i></td>
     <td headers="matches"><i>X</i> followed by <i>Y</i></td></tr>
 <tr><td valign="top" headers="construct logical"><i>X</i><tt>|</tt><i>Y</i></td>
     <td headers="matches">Either <i>X</i> or <i>Y</i></td></tr>
 <tr><td valign="top" headers="construct logical"><tt>(</tt><i>X</i><tt>)</tt></td>
     <td headers="matches">X, as a capturing group</td></tr>

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="backref"><b>Back references</b></td></tr>
 <tr><td valign="bottom" headers="construct backref"><tt>\</tt><i>n</i></td>
     <td valign="bottom" headers="matches">Whatever the <i>n</i><sup>th</sup>
     capturing group matched</td></tr>

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="quot"><b>Quotation</b></td></tr>

 <tr><td valign="top" headers="construct quot"><tt>\</tt></td>
     <td headers="matches">Nothing, but quotes the following character</td></tr>
 <tr><td valign="top" headers="construct quot"><tt>\Q</tt></td>
     <td headers="matches">Nothing, but quotes all characters until <tt>\E</tt></td></tr>
 <tr><td valign="top" headers="construct quot"><tt>\E</tt></td>
     <td headers="matches">Nothing, but ends quoting started by <tt>\Q</tt></td></tr>
     <!-- Metachars: !$()*+.<>?[\]^{|} -->

 <tr><td colspan="2">&nbsp;</td></tr>
 <tr align="left"><td colspan="2" id="special"><b>Special constructs (non-capturing)</b></td></tr>

 <tr><td valign="top" headers="construct special"><tt>(?:</tt><i>X</i><tt>)</tt></td>
     <td headers="matches"><i>X</i>, as a non-capturing group</td></tr>
 <tr><td valign="top" headers="construct special"><tt>(?idmsux-idmsux)&nbsp;</tt></td>
     <td headers="matches">Nothing, but turns match flags on - off</td></tr>
 <tr><td valign="top" headers="construct special"><tt>(?idmsux-idmsux:</tt><i>X</i><tt>)</tt>&nbsp;&nbsp;</td>
     <td headers="matches"><i>X</i>, as a non-capturing group with the
         given flags on - off</td></tr>
 <tr><td valign="top" headers="construct special"><tt>(?=</tt><i>X</i><tt>)</tt></td>
     <td headers="matches"><i>X</i>, via zero-width positive lookahead</td></tr>
 <tr><td valign="top" headers="construct special"><tt>(?!</tt><i>X</i><tt>)</tt></td>
     <td headers="matches"><i>X</i>, via zero-width negative lookahead</td></tr>
 <tr><td valign="top" headers="construct special"><tt>(?&lt;=</tt><i>X</i><tt>)</tt></td>
     <td headers="matches"><i>X</i>, via zero-width positive lookbehind</td></tr>
 <tr><td valign="top" headers="construct special"><tt>(?&lt;!</tt><i>X</i><tt>)</tt></td>
     <td headers="matches"><i>X</i>, via zero-width negative lookbehind</td></tr>
 <tr><td valign="top" headers="construct special"><tt>(?&gt;</tt><i>X</i><tt>)</tt></td>
     <td headers="matches"><i>X</i>, as an independent, non-capturing group</td></tr>

 </table>

<h3>Single Quoted Strings for Pattern Definition</h3>

<p>When constructing a regex pattern String it is usually best to use single quoted Sleep strings.  The benefit of single quoted 
strings is that only two escapes have meaning.   The <tt>\\</tt> and <tt>\'</tt> escapes resolve to <tt>\</tt> and <tt>'</tt> 
respectively.  A <tt>\</tt> followed by any other character is treated literally.</p>

<p>The regular expression-expression constructs above are based on the final value sent to the regex engine.  For example, to 
match a single <tt>\</tt>, the regex engine requires the <tt>\\</tt> sequence.  To construct a string to match this pattern one 
would have to create a string <tt>'\\\\'</tt> which is resolved into <tt>\\</tt> which is used by the regex engine to match a 
single <tt>\</tt>.  At least with single quoted strings one has to only worry about <tt>\\</tt> and <tt>\'</tt>.</p>

<h2><a name="15">Appendix D - Date/Time Formats</a></h2>

<p>Note: The following is modified from the documentation provided by Sun for the Java java.util.SimpleDateFormat class.  FYI for 
Sun, nice job on this API - I like it.</p>

<p>Date and time formats are specified by date and time pattern strings. Within date and time pattern strings, unquoted letters 
from 'A' to 'Z' and from 'a' to 'z' are interpreted as pattern letters representing the  components of a date or time string.  
Text can be quoted using ' single quotes to avoid  interpretation. 'at' represents the word at.</P>

<p>The following pattern letters are defined (all other characters from 'A' to 'Z' and from 'a' to 'z' are reserved):</P>

<table class="simple2" width="90%">
 <tr>
  <th>Letter</th>
  <th>Date or Time Component</th>
  <th>Examples</th>
 </tr>  

 <tr>
  <td>G</td>
  <td>Era designator</td>
  <td>AD</td>
 </tr>
 <tr>
  <td>y</td>
  <td>Year</td>
  <td>1996 ;96</td>
 </tr>
 <tr>
  <td>M</td>
  <td>Month in year</td>
  <td>July ;Jul ;07</td>
 </tr>
 <tr>
  <td>w</td>
  <td>Week in year</td>
  <td>27</td>
 </tr>
 <tr>
  <td>W</td>
  <td>Week in month</td>
  <td>2</td>
 </tr>
 <tr>
  <td>D</td>
  <td>Day in year</td>
  <td>189</td>
 </tr>
 <tr>
  <td>d</td>
  <td>Day in month</td>
  <td>10</td>
 </tr>
 <tr>
  <td>F</td>
  <td>Day of week in month</td>
  <td>2</td>
 </tr>
 <tr>
  <td>E</td>
  <td>Day in week</td>
  <td>Tuesday ;Tue</td>
 </tr>
 <tr>
  <td>a</td>
  <td>Am/pm marker</td>
  <td>PM</td>
 </tr>
 <tr>
  <td>H</td>
  <td>Hour in day (0-23)</td>
  <td>0</td>
 </tr>
 <tr>
  <td>k</td>
  <td>Hour in day (1-24)</td>
  <td>24</td>
 </tr>
 <tr>
  <td>K</td>
  <td>Hour in am/pm (0-11)</td>
  <td>0</td>
 </tr>
 <tr>
  <td>h</td>
  <td>Hour in am/pm (1-12)</td>
  <td>12</td>
 </tr>
 <tr>
  <td>m</td>
  <td>Minute in hour</td>
  <td>30</td>
 </tr>
 <tr>
  <td>s</td>
  <td>Second in minute</td>
  <td>55</td>
 </tr>
 <tr>
  <td>S</td>
  <td>Millisecond</td>
  <td>978</td>
 </tr>
 <tr>
  <td>z</td>
  <td>Time zone</td>
  <td>Pacific Standard Time ;PST  ;GMT-08:00</td>
 </tr>
 <tr>
  <td>Z</td>
  <td>Time zone</td>
  <td>-0800</td>
 </tr>
</table>

<p>Pattern letters are usually repeated, as their number determines the exact presentation:</p>

<p>For an item that is usually text i.e. the day of the week repeating the pattern letter 4x or more times results in the full 
form of the item being used.  Otherwise using the pattern letter less than 4x results in a shorter version of the text being 
used.</p>

<p>For formatting a year using yy will cause the year to be truncuated to 2 digits.</p>

<h3>Examples</h3>

<p>The following examples show how date and time patterns are interpreted in  the U.S. locale. The given date and time are 
2001-07-04 12:08:56 local time in the U.S. Pacific Time time zone.</p>

<table class="simple2" width="90%">
 <tr>
  <th width="255">Date and Time Pattern</th>
  <th>Result</th>
 </tr>  

 <tr>
  <td>"yyyy.MM.dd G 'at'  HH:mm:ss z"</td>
  <td>2001.07.04 AD at 12:08:56 PDT</td>
 </tr>
 <tr>
  <td>"EEE, MMM d, ''yy"</td>
  <td>Wed, Jul 4, '01</td>
 </tr>
 <tr>
  <td>"h:mm a"</td>
  <td>12:08 PM</td>
 </tr>
 <tr>
  <td>"hh 'o''clock' a,  zzzz"</td>
  <td>12 o'clock PM, Pacific Daylight  Time</td>
 </tr>
 <tr>
  <td>"K:mm a, z"</td>
  <td>0:08 PM, PDT</td>
 </tr>
 <tr>
  <td>"yyyyy.MMMMM.dd GGG  hh:mm aaa"</td>
  <td>02001.July.04 AD 12:08 PM</td>
 </tr>
 <tr>
  <td>"EEE, d MMM yyyy  HH:mm:ss Z"</td>
  <td>Wed, 4 Jul 2001 12:08:56  -0700</td>
 </tr>
 <tr>
  <td>"yyMMddHHmmssZ"</td>
  <td>010704120856-0700</td>
 </tr>
</table>

<h2><a name="16">Appendix E - Binary Data Format Strings</a></h2>

<p>Binary data format strings are used in the &amp;bread, &amp;bwrite, &amp;pack, and &amp;unpack functions.  An array of byte 
data is stored as a sleep string scalar.  Specifying a data format string with one of the above functions allows you to 
retrieve/store binary data into a string scalar or a file.</p>

<p>The data format string consists of the following characters:</p>

<table class="simple2" width="90%">
 <tr>
  <th width="0">Letter</th>
  <th width="0">Bytes</th>
  <th>Description</th>
 </tr>  
 <tr>
  <td>b</td>
  <td>1</td>
  <td>byte (-128 to 127) (converted to/from a sleep int)</td>
 </tr>
 <tr>
  <td>B</td>
  <td>1</td>
  <td>unsigned byte (0 to 255) (converted to/from a sleep int)</td>
 </tr>
 <tr>
  <td>c</td>
  <td>2</td>
  <td>UTF-16 Unicode character</td>
 </tr>
 <tr>
  <td>C</td>
  <td>1</td>
  <td>normal character</td>
 </tr>
 <tr>
  <td>d</td>
  <td>8</td>
  <td>double (uses IEEE 754 floating-point "double format" bit layout)</td>
 </tr>
 <tr>
  <td>f</td>
  <td>4</td>
  <td>float (uses IEEE 754 floating-point "single format" bit layout)</td>
 </tr>
 <tr>
  <td>h</td>
  <td>1</td>
  <td>a hex byte (low nybble first)</td>
 </tr>
 <tr>
  <td>H</td>
  <td>1</td>
  <td>a hex byte (high nybble first)</td>
 </tr>
 <tr>
  <td>i</td>
  <td>4</td>
  <td>integer</td>
 </tr>
 <tr>
  <td>I</td>
  <td>4</td>
  <td>unsigned integer (converted to/from a sleep long)</td>
 </tr>
 <tr>
  <td>l</td>
  <td>8</td>
  <td>long</td>
 </tr>
 <tr>
  <td>M</td>
  <td>0</td>
  <td>mark this point in the IO stream (for reads only)</td>
 </tr>
 <tr>
  <td>o</td>
  <td>variable</td>
  <td>sleep scalar object (used to serialize/deserialize scalars)</td>
 </tr>
 <tr>
  <td>R</td>
  <td>0</td>
  <td>reset this stream to the last mark point (reads only)</td>
 </tr>
 <tr>
  <td>s</td>
  <td>2</td>
  <td>short (converted to/from a sleep int)</td>
 </tr>
  <tr>
  <td>S</td>
  <td>2</td>
  <td>unsigned short (converted to/from a sleep int)</td>
 </tr>
 <tr>
  <td>u</td>
  <td>variable</td>
  <td>read/write UTF-16 character data until terminated with a null byte. (see <a href="#snote">note</a> below)</td>
 </tr>
 <tr>
  <td>U</td>
  <td>variable</td>
  <td>read/write the specified number of UTF-16 characters (consumes the whole field)</td>
 </tr>
 <tr>
  <td>x</td>
  <td>1</td>
  <td>skips a byte/writes a nully byte in/to this stream (no data returned)</td>
 </tr>
 <tr>
  <td>z</td>
  <td>variable</td>
  <td>read/write character data until terminated with a null byte. (see <a href="#snote">note</a> below)</td>
 </tr>
 <tr>
  <td>Z</td>
  <td>variable</td>
  <td>read/write the specified number of characters (consumes the whole field)</td>
 </tr>
</table>

<p>Any of the above data descriptors can be followed by an integer that says to repeat this descriptor a number of times.  Use 
of the '*' character following a data descriptor indicates you want the rest of the data to be read as the specified type.  
Whitespace is ignored inside of data format strings.</p>

<p>By default the byte order for all reads/writes is network byte order (big endian).  An endianess can be specified 
for each data read/written using these format characters.  Append a + to the format character to indicate big endian byte 
order.  Append a - to the format character to indicate little endian byte order.  To use the platform native byte order append 
a ! to the format character.</p>

<p>To determine the native byte order of the host system:</p>

<pre>$endianess = iff(unpack('i!', pack('i+', 1))[0] == 1, "big endian", "little endian");</pre>

<a name="snote"></a><p><font color="red">u/U/z/Z Note:</font> Writes using Z/U will pad until the specified count is reached.
If no count is specified a \0 is guaranteed to be written.  If the string length is the same as the specified count no \0 will 
be written.  The values z/u will write the entire string with a guaranteed \0 always (two \0's for UTF-16).  The count value 
has no effect on z/u.  Consequently for reads, Z/U will always consume the number of characters specified in the count.  For 
reads z/u will keep reading until a \0 is found.  U/u strings always read/write 2-byte characters.</p>

<h2><a name="17">Appendix F - Transliteration</a></h2>

<p>Sleep provides a character translation utility similar to the UNIX tr command with the <code>&amp;tr</code> function..
A transliteration consists of a pattern of characters to match and a pattern, typically of equal length, of characters to 
replace each match with.  The tr utility loops through a specified string character by character.  Each character is compared 
against the pattern of matching characters.  If the character matches one of the pattern characters it is either replaced with 
the replacement character mapped to that matcher or it is deleted.  Which action is taken depends on what options are 
specified.</p>

<p>The following example is an ROT13 Translator using the <code>&amp;tr</code> function:</p>

<pre># A simple ROT13 Translator (for extra security run it twice...)

$cipher = tr("sleep rocks", "a-z", "n-za-m");
$plain  = tr($cipher, "a-z", "n-za-m");

println("Cipher: $cipher   Plain: $plain");</pre>

<p>Replacement patterns and Matcher patterns may both contain ranges.  Any range specified in either of these places will be
expanded to all of the characters.  A range is specified as <code><i>n</i>-<i>m</i></code> where <i>n</i> is the
starting character (A-Z, a-z, 0-9) and <i>m</i> is the ending character.  Backwards ranges are allowed as well.</p>

<p>If an expanded replacement pattern is shorter than the matcher pattern, the last character of the replacement pattern
will be used to map to all remaining characters in the matcher pattern.  The <code>d</code>elete option changes this
behavior to delete those matches that don't have a replacement pattern character explicitly mapped to them.</p>

<p>Matcher patterns may contain the following character classes:</p>

<table width="90%" class="simple2"> 
  <tr><th width="100" align="left">Sequence</th><th align="left">Meaning</th></tr>
  <tr><td>.</td><td>Matches any character</td></tr>
  <tr><td>\d</td><td>Matches any digit 0-9</td></tr>
  <tr><td>\D</td><td>Matches any non-digit</td></tr>
  <tr><td>\s</td><td>Matches any whitespace character</td></tr>
  <tr><td>\S</td><td>Matches any non-whitespace character</td></tr>
  <tr><td>\w</td><td>Matches any letter</td></tr>
  <tr><td>\W</td><td>Matches any non-letter</td></tr>
  <tr><td>\\</td><td>Matches a literal backslash</td></tr>
  <tr><td>\.</td><td>Matches a literal period</td></tr>
  <tr><td>\-</td><td>Matches a literal dash</td></tr>
</table>

<p>Transliteration patterns have several options that can change the behavior of the matcher/translator.  The optional 
fourth parameter can consist of any combination of the letters c, d, and s.  These options are explained below.</p>

 <p><code>d</code>elete - tells the translator to delete matching characters if there is no mapped character specified
 in the replacement pattern.</p>

 <p><code>c</code>omplement -  negates the compiled pattern.  When this flag is set all characters and meta-characters will
 match their compliments.</p>

 <p><code>s</code>queeze - is used to force the translator to squeeze together matches right next to eachother.  
Essentially this option will delete repeated characters that match a pattern character.</p>


</body>
</html>
